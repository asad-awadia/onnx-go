// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onnx.proto3

package ir

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Versioning
//
// ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
//
// To be compatible with both proto2 and proto3, we will use a version number
// that is not defined by the default value but an explicit enum number.
type Version int32

const (
	// proto3 requires the first enum value to be zero.
	// We add this just to appease the compiler.
	Version__START_VERSION Version = 0
	// The version field is always serialized and we will use it to store the
	// version that the  graph is generated from. This helps us set up version
	// control.
	// For the IR, we are using simple numbers starting with with 0x00000001,
	// which was the version we published on Oct 10, 2017.
	Version_IR_VERSION_2017_10_10 Version = 1
	// IR_VERSION 2 published on Oct 30, 2017
	// - Added type discriminator to AttributeProto to support proto3 users
	Version_IR_VERSION_2017_10_30 Version = 2
	// IR VERSION 3 published on Nov 3, 2017
	// - For operator versioning:
	//    - Added new message OperatorSetIdProto
	//    - Added opset_import in ModelProto
	// - For vendor extensions, added domain in NodeProto
	Version_IR_VERSION_2017_11_3 Version = 3
	// IR VERSION 4 published on Jan 22, 2019
	// - Relax constraint that initializers should be a subset of graph inputs
	// - Add type BFLOAT16
	Version_IR_VERSION_2019_1_22 Version = 4
	// IR VERSION 5 published on March 18, 2019
	// - Add message TensorAnnotation.
	// - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
	Version_IR_VERSION Version = 5
)

var Version_name = map[int32]string{
	0: "_START_VERSION",
	1: "IR_VERSION_2017_10_10",
	2: "IR_VERSION_2017_10_30",
	3: "IR_VERSION_2017_11_3",
	4: "IR_VERSION_2019_1_22",
	5: "IR_VERSION",
}

var Version_value = map[string]int32{
	"_START_VERSION":        0,
	"IR_VERSION_2017_10_10": 1,
	"IR_VERSION_2017_10_30": 2,
	"IR_VERSION_2017_11_3":  3,
	"IR_VERSION_2019_1_22":  4,
	"IR_VERSION":            5,
}

func (x Version) String() string {
	return proto.EnumName(Version_name, int32(x))
}

func (Version) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{0}
}

// Note: this enum is structurally identical to the OpSchema::AttrType
// enum defined in schema.h.  If you rev one, you likely need to rev the other.
type AttributeProto_AttributeType int32

const (
	AttributeProto_UNDEFINED AttributeProto_AttributeType = 0
	AttributeProto_FLOAT     AttributeProto_AttributeType = 1
	AttributeProto_INT       AttributeProto_AttributeType = 2
	AttributeProto_STRING    AttributeProto_AttributeType = 3
	AttributeProto_TENSOR    AttributeProto_AttributeType = 4
	AttributeProto_GRAPH     AttributeProto_AttributeType = 5
	AttributeProto_FLOATS    AttributeProto_AttributeType = 6
	AttributeProto_INTS      AttributeProto_AttributeType = 7
	AttributeProto_STRINGS   AttributeProto_AttributeType = 8
	AttributeProto_TENSORS   AttributeProto_AttributeType = 9
	AttributeProto_GRAPHS    AttributeProto_AttributeType = 10
)

var AttributeProto_AttributeType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "FLOAT",
	2:  "INT",
	3:  "STRING",
	4:  "TENSOR",
	5:  "GRAPH",
	6:  "FLOATS",
	7:  "INTS",
	8:  "STRINGS",
	9:  "TENSORS",
	10: "GRAPHS",
}

var AttributeProto_AttributeType_value = map[string]int32{
	"UNDEFINED": 0,
	"FLOAT":     1,
	"INT":       2,
	"STRING":    3,
	"TENSOR":    4,
	"GRAPH":     5,
	"FLOATS":    6,
	"INTS":      7,
	"STRINGS":   8,
	"TENSORS":   9,
	"GRAPHS":    10,
}

func (x AttributeProto_AttributeType) String() string {
	return proto.EnumName(AttributeProto_AttributeType_name, int32(x))
}

func (AttributeProto_AttributeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{0, 0}
}

type TensorProto_DataType int32

const (
	TensorProto_UNDEFINED TensorProto_DataType = 0
	// Basic types.
	TensorProto_FLOAT  TensorProto_DataType = 1
	TensorProto_UINT8  TensorProto_DataType = 2
	TensorProto_INT8   TensorProto_DataType = 3
	TensorProto_UINT16 TensorProto_DataType = 4
	TensorProto_INT16  TensorProto_DataType = 5
	TensorProto_INT32  TensorProto_DataType = 6
	TensorProto_INT64  TensorProto_DataType = 7
	TensorProto_STRING TensorProto_DataType = 8
	TensorProto_BOOL   TensorProto_DataType = 9
	// IEEE754 half-precision floating-point format (16 bits wide).
	// This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
	TensorProto_FLOAT16    TensorProto_DataType = 10
	TensorProto_DOUBLE     TensorProto_DataType = 11
	TensorProto_UINT32     TensorProto_DataType = 12
	TensorProto_UINT64     TensorProto_DataType = 13
	TensorProto_COMPLEX64  TensorProto_DataType = 14
	TensorProto_COMPLEX128 TensorProto_DataType = 15
	// Non-IEEE floating-point format based on IEEE754 single-precision
	// floating-point number truncated to 16 bits.
	// This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
	TensorProto_BFLOAT16 TensorProto_DataType = 16
)

var TensorProto_DataType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "FLOAT",
	2:  "UINT8",
	3:  "INT8",
	4:  "UINT16",
	5:  "INT16",
	6:  "INT32",
	7:  "INT64",
	8:  "STRING",
	9:  "BOOL",
	10: "FLOAT16",
	11: "DOUBLE",
	12: "UINT32",
	13: "UINT64",
	14: "COMPLEX64",
	15: "COMPLEX128",
	16: "BFLOAT16",
}

var TensorProto_DataType_value = map[string]int32{
	"UNDEFINED":  0,
	"FLOAT":      1,
	"UINT8":      2,
	"INT8":       3,
	"UINT16":     4,
	"INT16":      5,
	"INT32":      6,
	"INT64":      7,
	"STRING":     8,
	"BOOL":       9,
	"FLOAT16":    10,
	"DOUBLE":     11,
	"UINT32":     12,
	"UINT64":     13,
	"COMPLEX64":  14,
	"COMPLEX128": 15,
	"BFLOAT16":   16,
}

func (x TensorProto_DataType) String() string {
	return proto.EnumName(TensorProto_DataType_name, int32(x))
}

func (TensorProto_DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{7, 0}
}

// Location of the data for this tensor. MUST be one of:
// - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
// - EXTERNAL - data stored in an external location as described by external_data field.
type TensorProto_DataLocation int32

const (
	TensorProto_DEFAULT  TensorProto_DataLocation = 0
	TensorProto_EXTERNAL TensorProto_DataLocation = 1
)

var TensorProto_DataLocation_name = map[int32]string{
	0: "DEFAULT",
	1: "EXTERNAL",
}

var TensorProto_DataLocation_value = map[string]int32{
	"DEFAULT":  0,
	"EXTERNAL": 1,
}

func (x TensorProto_DataLocation) String() string {
	return proto.EnumName(TensorProto_DataLocation_name, int32(x))
}

func (TensorProto_DataLocation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{7, 1}
}

// Attributes
//
// A named attribute containing either singular float, integer, string, graph,
// and tensor values, or repeated float, integer, string, graph, and tensor values.
// An AttributeProto MUST contain the name field, and *only one* of the
// following content fields, effectively enforcing a C/C++ union equivalent.
type AttributeProto struct {
	// The name field MUST be present for this version of the IR.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
	// In this case, this AttributeProto does not contain data, and it's a reference of attribute
	// in parent scope.
	// NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
	RefAttrName string `protobuf:"bytes,21,opt,name=ref_attr_name,json=refAttrName,proto3" json:"ref_attr_name,omitempty"`
	// A human-readable documentation for this attribute. Markdown is allowed.
	DocString string `protobuf:"bytes,13,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
	// The type field MUST be present for this version of the IR.
	// For 0.0.1 versions of the IR, this field was not defined, and
	// implementations needed to use has_field hueristics to determine
	// which value field was in use.  For IR_VERSION 0.0.2 or later, this
	// field MUST be set and match the f|i|s|t|... field in use.  This
	// change was made to accomodate proto3 implementations.
	Type AttributeProto_AttributeType `protobuf:"varint,20,opt,name=type,proto3,enum=onnx.AttributeProto_AttributeType" json:"type,omitempty"`
	// Exactly ONE of the following fields must be present for this version of the IR
	F       float32        `protobuf:"fixed32,2,opt,name=f,proto3" json:"f,omitempty"`
	I       int64          `protobuf:"varint,3,opt,name=i,proto3" json:"i,omitempty"`
	S       []byte         `protobuf:"bytes,4,opt,name=s,proto3" json:"s,omitempty"`
	T       *TensorProto   `protobuf:"bytes,5,opt,name=t,proto3" json:"t,omitempty"`
	G       *GraphProto    `protobuf:"bytes,6,opt,name=g,proto3" json:"g,omitempty"`
	Floats  []float32      `protobuf:"fixed32,7,rep,packed,name=floats,proto3" json:"floats,omitempty"`
	Ints    []int64        `protobuf:"varint,8,rep,packed,name=ints,proto3" json:"ints,omitempty"`
	Strings [][]byte       `protobuf:"bytes,9,rep,name=strings,proto3" json:"strings,omitempty"`
	Tensors []*TensorProto `protobuf:"bytes,10,rep,name=tensors,proto3" json:"tensors,omitempty"`
	Graphs  []*GraphProto  `protobuf:"bytes,11,rep,name=graphs,proto3" json:"graphs,omitempty"`
}

func (m *AttributeProto) Reset()         { *m = AttributeProto{} }
func (m *AttributeProto) String() string { return proto.CompactTextString(m) }
func (*AttributeProto) ProtoMessage()    {}
func (*AttributeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{0}
}
func (m *AttributeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttributeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttributeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttributeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeProto.Merge(m, src)
}
func (m *AttributeProto) XXX_Size() int {
	return m.Size()
}
func (m *AttributeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeProto.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeProto proto.InternalMessageInfo

func (m *AttributeProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttributeProto) GetRefAttrName() string {
	if m != nil {
		return m.RefAttrName
	}
	return ""
}

func (m *AttributeProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

func (m *AttributeProto) GetType() AttributeProto_AttributeType {
	if m != nil {
		return m.Type
	}
	return AttributeProto_UNDEFINED
}

func (m *AttributeProto) GetF() float32 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *AttributeProto) GetI() int64 {
	if m != nil {
		return m.I
	}
	return 0
}

func (m *AttributeProto) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *AttributeProto) GetT() *TensorProto {
	if m != nil {
		return m.T
	}
	return nil
}

func (m *AttributeProto) GetG() *GraphProto {
	if m != nil {
		return m.G
	}
	return nil
}

func (m *AttributeProto) GetFloats() []float32 {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *AttributeProto) GetInts() []int64 {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *AttributeProto) GetStrings() [][]byte {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *AttributeProto) GetTensors() []*TensorProto {
	if m != nil {
		return m.Tensors
	}
	return nil
}

func (m *AttributeProto) GetGraphs() []*GraphProto {
	if m != nil {
		return m.Graphs
	}
	return nil
}

// Defines information on value, including the name, the type, and
// the shape of the value.
type ValueInfoProto struct {
	// This field MUST be present in this version of the IR.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field MUST be present in this version of the IR.
	Type *TypeProto `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// A human-readable documentation for this value. Markdown is allowed.
	DocString string `protobuf:"bytes,3,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
}

func (m *ValueInfoProto) Reset()         { *m = ValueInfoProto{} }
func (m *ValueInfoProto) String() string { return proto.CompactTextString(m) }
func (*ValueInfoProto) ProtoMessage()    {}
func (*ValueInfoProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{1}
}
func (m *ValueInfoProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueInfoProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueInfoProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueInfoProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueInfoProto.Merge(m, src)
}
func (m *ValueInfoProto) XXX_Size() int {
	return m.Size()
}
func (m *ValueInfoProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueInfoProto.DiscardUnknown(m)
}

var xxx_messageInfo_ValueInfoProto proto.InternalMessageInfo

func (m *ValueInfoProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ValueInfoProto) GetType() *TypeProto {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ValueInfoProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

// Nodes
//
// Computation graphs are made up of a DAG of nodes, which represent what is
// commonly called a "layer" or "pipeline stage" in machine learning frameworks.
//
// For example, it can be a node of type "Conv" that takes in an image, a filter
// tensor and a bias tensor, and produces the convolved output.
type NodeProto struct {
	Input  []string `protobuf:"bytes,1,rep,name=input,proto3" json:"input,omitempty"`
	Output []string `protobuf:"bytes,2,rep,name=output,proto3" json:"output,omitempty"`
	// An optional identifier for this node in a graph.
	// This field MAY be absent in ths version of the IR.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The symbolic identifier of the Operator to execute.
	OpType string `protobuf:"bytes,4,opt,name=op_type,json=opType,proto3" json:"op_type,omitempty"`
	// The domain of the OperatorSet that specifies the operator named by op_type.
	Domain string `protobuf:"bytes,7,opt,name=domain,proto3" json:"domain,omitempty"`
	// Additional named attributes.
	Attribute []*AttributeProto `protobuf:"bytes,5,rep,name=attribute,proto3" json:"attribute,omitempty"`
	// A human-readable documentation for this node. Markdown is allowed.
	DocString string `protobuf:"bytes,6,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
}

func (m *NodeProto) Reset()         { *m = NodeProto{} }
func (m *NodeProto) String() string { return proto.CompactTextString(m) }
func (*NodeProto) ProtoMessage()    {}
func (*NodeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{2}
}
func (m *NodeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeProto.Merge(m, src)
}
func (m *NodeProto) XXX_Size() int {
	return m.Size()
}
func (m *NodeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeProto.DiscardUnknown(m)
}

var xxx_messageInfo_NodeProto proto.InternalMessageInfo

func (m *NodeProto) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *NodeProto) GetOutput() []string {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *NodeProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeProto) GetOpType() string {
	if m != nil {
		return m.OpType
	}
	return ""
}

func (m *NodeProto) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *NodeProto) GetAttribute() []*AttributeProto {
	if m != nil {
		return m.Attribute
	}
	return nil
}

func (m *NodeProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

// Models
//
// ModelProto is a top-level file/container format for bundling a ML model and
// associating its computation graph with metadata.
//
// The semantics of the model are described by the associated GraphProto.
type ModelProto struct {
	// The version of the IR this model targets. See Version enum above.
	// This field MUST be present.
	IrVersion int64 `protobuf:"varint,1,opt,name=ir_version,json=irVersion,proto3" json:"ir_version,omitempty"`
	// The OperatorSets this model relies on.
	// All ModelProtos MUST have at least one entry that
	// specifies which version of the ONNX OperatorSet is
	// being imported.
	//
	// All nodes in the ModelProto's graph will bind against the operator
	// with the same-domain/same-op_type operator with the HIGHEST version
	// in the referenced operator sets.
	OpsetImport []*OperatorSetIdProto `protobuf:"bytes,8,rep,name=opset_import,json=opsetImport,proto3" json:"opset_import,omitempty"`
	// The name of the framework or tool used to generate this model.
	// This field SHOULD be present to indicate which implementation/tool/framework
	// emitted the model.
	ProducerName string `protobuf:"bytes,2,opt,name=producer_name,json=producerName,proto3" json:"producer_name,omitempty"`
	// The version of the framework or tool used to generate this model.
	// This field SHOULD be present to indicate which implementation/tool/framework
	// emitted the model.
	ProducerVersion string `protobuf:"bytes,3,opt,name=producer_version,json=producerVersion,proto3" json:"producer_version,omitempty"`
	// Domain name of the model.
	// We use reverse domain names as name space indicators. For example:
	// `com.facebook.fair` or `com.microsoft.cognitiveservices`
	//
	// Together with `model_version` and GraphProto.name, this forms the unique identity of
	// the graph.
	Domain string `protobuf:"bytes,4,opt,name=domain,proto3" json:"domain,omitempty"`
	// The version of the graph encoded. See Version enum below.
	ModelVersion int64 `protobuf:"varint,5,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// A human-readable documentation for this model. Markdown is allowed.
	DocString string `protobuf:"bytes,6,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
	// The parameterized graph that is evaluated to execute the model.
	Graph *GraphProto `protobuf:"bytes,7,opt,name=graph,proto3" json:"graph,omitempty"`
	// Named metadata values; keys should be distinct.
	MetadataProps []*StringStringEntryProto `protobuf:"bytes,14,rep,name=metadata_props,json=metadataProps,proto3" json:"metadata_props,omitempty"`
}

func (m *ModelProto) Reset()         { *m = ModelProto{} }
func (m *ModelProto) String() string { return proto.CompactTextString(m) }
func (*ModelProto) ProtoMessage()    {}
func (*ModelProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{3}
}
func (m *ModelProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelProto.Merge(m, src)
}
func (m *ModelProto) XXX_Size() int {
	return m.Size()
}
func (m *ModelProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelProto.DiscardUnknown(m)
}

var xxx_messageInfo_ModelProto proto.InternalMessageInfo

func (m *ModelProto) GetIrVersion() int64 {
	if m != nil {
		return m.IrVersion
	}
	return 0
}

func (m *ModelProto) GetOpsetImport() []*OperatorSetIdProto {
	if m != nil {
		return m.OpsetImport
	}
	return nil
}

func (m *ModelProto) GetProducerName() string {
	if m != nil {
		return m.ProducerName
	}
	return ""
}

func (m *ModelProto) GetProducerVersion() string {
	if m != nil {
		return m.ProducerVersion
	}
	return ""
}

func (m *ModelProto) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *ModelProto) GetModelVersion() int64 {
	if m != nil {
		return m.ModelVersion
	}
	return 0
}

func (m *ModelProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

func (m *ModelProto) GetGraph() *GraphProto {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *ModelProto) GetMetadataProps() []*StringStringEntryProto {
	if m != nil {
		return m.MetadataProps
	}
	return nil
}

// StringStringEntryProto follows the pattern for cross-proto-version maps.
// See https://developers.google.com/protocol-buffers/docs/proto3#maps
type StringStringEntryProto struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *StringStringEntryProto) Reset()         { *m = StringStringEntryProto{} }
func (m *StringStringEntryProto) String() string { return proto.CompactTextString(m) }
func (*StringStringEntryProto) ProtoMessage()    {}
func (*StringStringEntryProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{4}
}
func (m *StringStringEntryProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringStringEntryProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringStringEntryProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringStringEntryProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringStringEntryProto.Merge(m, src)
}
func (m *StringStringEntryProto) XXX_Size() int {
	return m.Size()
}
func (m *StringStringEntryProto) XXX_DiscardUnknown() {
	xxx_messageInfo_StringStringEntryProto.DiscardUnknown(m)
}

var xxx_messageInfo_StringStringEntryProto proto.InternalMessageInfo

func (m *StringStringEntryProto) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringStringEntryProto) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type TensorAnnotation struct {
	TensorName string `protobuf:"bytes,1,opt,name=tensor_name,json=tensorName,proto3" json:"tensor_name,omitempty"`
	// <key, value> pairs to annotate tensor specified by <tensor_name> above.
	// The keys used in the mapping below must be pre-defined in ONNX spec.
	// For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
	// quantization parameter keys.
	QuantParameterTensorNames []*StringStringEntryProto `protobuf:"bytes,2,rep,name=quant_parameter_tensor_names,json=quantParameterTensorNames,proto3" json:"quant_parameter_tensor_names,omitempty"`
}

func (m *TensorAnnotation) Reset()         { *m = TensorAnnotation{} }
func (m *TensorAnnotation) String() string { return proto.CompactTextString(m) }
func (*TensorAnnotation) ProtoMessage()    {}
func (*TensorAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{5}
}
func (m *TensorAnnotation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorAnnotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorAnnotation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorAnnotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorAnnotation.Merge(m, src)
}
func (m *TensorAnnotation) XXX_Size() int {
	return m.Size()
}
func (m *TensorAnnotation) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorAnnotation.DiscardUnknown(m)
}

var xxx_messageInfo_TensorAnnotation proto.InternalMessageInfo

func (m *TensorAnnotation) GetTensorName() string {
	if m != nil {
		return m.TensorName
	}
	return ""
}

func (m *TensorAnnotation) GetQuantParameterTensorNames() []*StringStringEntryProto {
	if m != nil {
		return m.QuantParameterTensorNames
	}
	return nil
}

// Graphs
//
// A graph defines the computational logic of a model and is comprised of a parameterized
// list of nodes that form a directed acyclic graph based on their inputs and outputs.
// This is the equivalent of the "network" or "graph" in many deep learning
// frameworks.
type GraphProto struct {
	// The nodes in the graph, sorted topologically.
	Node []*NodeProto `protobuf:"bytes,1,rep,name=node,proto3" json:"node,omitempty"`
	// The name of the graph.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// A list of named tensor values, used to specify constant inputs of the graph.
	// Each TensorProto entry must have a distinct name (within the list) that
	// MAY also appear in the input list.
	Initializer []*TensorProto `protobuf:"bytes,5,rep,name=initializer,proto3" json:"initializer,omitempty"`
	// A human-readable documentation for this graph. Markdown is allowed.
	DocString string `protobuf:"bytes,10,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
	// The inputs and outputs of the graph.
	Input  []*ValueInfoProto `protobuf:"bytes,11,rep,name=input,proto3" json:"input,omitempty"`
	Output []*ValueInfoProto `protobuf:"bytes,12,rep,name=output,proto3" json:"output,omitempty"`
	// Information for the values in the graph. The ValueInfoProto.name's
	// must be distinct. It is optional for a value to appear in value_info list.
	ValueInfo []*ValueInfoProto `protobuf:"bytes,13,rep,name=value_info,json=valueInfo,proto3" json:"value_info,omitempty"`
	// This field carries information to indicate the mapping among a tensor and its
	// quantization parameter tensors. For example:
	// For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
	// which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
	QuantizationAnnotation []*TensorAnnotation `protobuf:"bytes,14,rep,name=quantization_annotation,json=quantizationAnnotation,proto3" json:"quantization_annotation,omitempty"`
}

func (m *GraphProto) Reset()         { *m = GraphProto{} }
func (m *GraphProto) String() string { return proto.CompactTextString(m) }
func (*GraphProto) ProtoMessage()    {}
func (*GraphProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{6}
}
func (m *GraphProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GraphProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GraphProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GraphProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphProto.Merge(m, src)
}
func (m *GraphProto) XXX_Size() int {
	return m.Size()
}
func (m *GraphProto) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphProto.DiscardUnknown(m)
}

var xxx_messageInfo_GraphProto proto.InternalMessageInfo

func (m *GraphProto) GetNode() []*NodeProto {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *GraphProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphProto) GetInitializer() []*TensorProto {
	if m != nil {
		return m.Initializer
	}
	return nil
}

func (m *GraphProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

func (m *GraphProto) GetInput() []*ValueInfoProto {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *GraphProto) GetOutput() []*ValueInfoProto {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *GraphProto) GetValueInfo() []*ValueInfoProto {
	if m != nil {
		return m.ValueInfo
	}
	return nil
}

func (m *GraphProto) GetQuantizationAnnotation() []*TensorAnnotation {
	if m != nil {
		return m.QuantizationAnnotation
	}
	return nil
}

// Tensors
//
// A serialized tensor value.
type TensorProto struct {
	// The shape of the tensor.
	Dims []int64 `protobuf:"varint,1,rep,packed,name=dims,proto3" json:"dims,omitempty"`
	// The data type of the tensor.
	// This field MUST have a valid TensorProto.DataType value
	DataType int32                `protobuf:"varint,2,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	Segment  *TensorProto_Segment `protobuf:"bytes,3,opt,name=segment,proto3" json:"segment,omitempty"`
	// For float and complex64 values
	// Complex64 tensors are encoded as a single array of floats,
	// with the real components appearing in odd numbered positions,
	// and the corresponding imaginary component apparing in the
	// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
	// is encoded as [1.0, 2.0 ,3.0 ,4.0]
	// When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
	FloatData []float32 `protobuf:"fixed32,4,rep,packed,name=float_data,json=floatData,proto3" json:"float_data,omitempty"`
	// For int32, uint8, int8, uint16, int16, bool, and float16 values
	// float16 values must be bit-wise converted to an uint16_t prior
	// to writing to the buffer.
	// When this field is present, the data_type field MUST be
	// INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
	Int32Data []int32 `protobuf:"varint,5,rep,packed,name=int32_data,json=int32Data,proto3" json:"int32_data,omitempty"`
	// For strings.
	// Each element of string_data is a UTF-8 encoded Unicode
	// string. No trailing null, no leading BOM. The protobuf "string"
	// scalar type is not used to match ML community conventions.
	// When this field is present, the data_type field MUST be STRING
	StringData [][]byte `protobuf:"bytes,6,rep,name=string_data,json=stringData,proto3" json:"string_data,omitempty"`
	// For int64.
	// When this field is present, the data_type field MUST be INT64
	Int64Data []int64 `protobuf:"varint,7,rep,packed,name=int64_data,json=int64Data,proto3" json:"int64_data,omitempty"`
	// Optionally, a name for the tensor.
	Name string `protobuf:"bytes,8,opt,name=name,proto3" json:"name,omitempty"`
	// A human-readable documentation for this tensor. Markdown is allowed.
	DocString string `protobuf:"bytes,12,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
	// Serializations can either use one of the fields above, or use this
	// raw bytes field. The only exception is the string case, where one is
	// required to store the content in the repeated bytes string_data field.
	//
	// When this raw_data field is used to store tensor value, elements MUST
	// be stored in as fixed-width, little-endian order.
	// Floating-point data types MUST be stored in IEEE 754 format.
	// Complex64 elements must be written as two consecutive FLOAT values, real component first.
	// Complex128 elements must be written as two consecutive DOUBLE values, real component first.
	// Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
	//
	// Note: the advantage of specific field rather than the raw_data field is
	// that in some cases (e.g. int data), protobuf does a better packing via
	// variable length storage, and may lead to smaller binary footprint.
	// When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
	RawData []byte `protobuf:"bytes,9,opt,name=raw_data,json=rawData,proto3" json:"raw_data,omitempty"`
	// Data can be stored inside the protobuf file using type-specific fields or raw_data.
	// Alternatively, raw bytes data can be stored in an external file, using the external_data field.
	// external_data stores key-value pairs describing data location. Recognized keys are:
	// - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
	//                           protobuf model was stored
	// - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
	//                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
	// - "length" (optional) - number of bytes containing data. Integer stored as string.
	// - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
	ExternalData []*StringStringEntryProto `protobuf:"bytes,13,rep,name=external_data,json=externalData,proto3" json:"external_data,omitempty"`
	// If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
	DataLocation TensorProto_DataLocation `protobuf:"varint,14,opt,name=data_location,json=dataLocation,proto3,enum=onnx.TensorProto_DataLocation" json:"data_location,omitempty"`
	// For double
	// Complex128 tensors are encoded as a single array of doubles,
	// with the real components appearing in odd numbered positions,
	// and the corresponding imaginary component apparing in the
	// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
	// is encoded as [1.0, 2.0 ,3.0 ,4.0]
	// When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
	DoubleData []float64 `protobuf:"fixed64,10,rep,packed,name=double_data,json=doubleData,proto3" json:"double_data,omitempty"`
	// For uint64 and uint32 values
	// When this field is present, the data_type field MUST be
	// UINT32 or UINT64
	Uint64Data []uint64 `protobuf:"varint,11,rep,packed,name=uint64_data,json=uint64Data,proto3" json:"uint64_data,omitempty"`
}

func (m *TensorProto) Reset()         { *m = TensorProto{} }
func (m *TensorProto) String() string { return proto.CompactTextString(m) }
func (*TensorProto) ProtoMessage()    {}
func (*TensorProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{7}
}
func (m *TensorProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorProto.Merge(m, src)
}
func (m *TensorProto) XXX_Size() int {
	return m.Size()
}
func (m *TensorProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorProto.DiscardUnknown(m)
}

var xxx_messageInfo_TensorProto proto.InternalMessageInfo

func (m *TensorProto) GetDims() []int64 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *TensorProto) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *TensorProto) GetSegment() *TensorProto_Segment {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *TensorProto) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *TensorProto) GetInt32Data() []int32 {
	if m != nil {
		return m.Int32Data
	}
	return nil
}

func (m *TensorProto) GetStringData() [][]byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

func (m *TensorProto) GetInt64Data() []int64 {
	if m != nil {
		return m.Int64Data
	}
	return nil
}

func (m *TensorProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TensorProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

func (m *TensorProto) GetRawData() []byte {
	if m != nil {
		return m.RawData
	}
	return nil
}

func (m *TensorProto) GetExternalData() []*StringStringEntryProto {
	if m != nil {
		return m.ExternalData
	}
	return nil
}

func (m *TensorProto) GetDataLocation() TensorProto_DataLocation {
	if m != nil {
		return m.DataLocation
	}
	return TensorProto_DEFAULT
}

func (m *TensorProto) GetDoubleData() []float64 {
	if m != nil {
		return m.DoubleData
	}
	return nil
}

func (m *TensorProto) GetUint64Data() []uint64 {
	if m != nil {
		return m.Uint64Data
	}
	return nil
}

// For very large tensors, we may want to store them in chunks, in which
// case the following fields will specify the segment that is stored in
// the current TensorProto.
type TensorProto_Segment struct {
	Begin int64 `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End   int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *TensorProto_Segment) Reset()         { *m = TensorProto_Segment{} }
func (m *TensorProto_Segment) String() string { return proto.CompactTextString(m) }
func (*TensorProto_Segment) ProtoMessage()    {}
func (*TensorProto_Segment) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{7, 0}
}
func (m *TensorProto_Segment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorProto_Segment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorProto_Segment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorProto_Segment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorProto_Segment.Merge(m, src)
}
func (m *TensorProto_Segment) XXX_Size() int {
	return m.Size()
}
func (m *TensorProto_Segment) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorProto_Segment.DiscardUnknown(m)
}

var xxx_messageInfo_TensorProto_Segment proto.InternalMessageInfo

func (m *TensorProto_Segment) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *TensorProto_Segment) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

// Defines a tensor shape. A dimension can be either an integer value
// or a symbolic variable. A symbolic variable represents an unknown
// dimension.
type TensorShapeProto struct {
	Dim []*TensorShapeProto_Dimension `protobuf:"bytes,1,rep,name=dim,proto3" json:"dim,omitempty"`
}

func (m *TensorShapeProto) Reset()         { *m = TensorShapeProto{} }
func (m *TensorShapeProto) String() string { return proto.CompactTextString(m) }
func (*TensorShapeProto) ProtoMessage()    {}
func (*TensorShapeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{8}
}
func (m *TensorShapeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorShapeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorShapeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorShapeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorShapeProto.Merge(m, src)
}
func (m *TensorShapeProto) XXX_Size() int {
	return m.Size()
}
func (m *TensorShapeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorShapeProto.DiscardUnknown(m)
}

var xxx_messageInfo_TensorShapeProto proto.InternalMessageInfo

func (m *TensorShapeProto) GetDim() []*TensorShapeProto_Dimension {
	if m != nil {
		return m.Dim
	}
	return nil
}

type TensorShapeProto_Dimension struct {
	// Types that are valid to be assigned to Value:
	//	*TensorShapeProto_Dimension_DimValue
	//	*TensorShapeProto_Dimension_DimParam
	Value isTensorShapeProto_Dimension_Value `protobuf_oneof:"value"`
	// Standard denotation can optionally be used to denote tensor
	// dimensions with standard semantic descriptions to ensure
	// that operations are applied to the correct axis of a tensor.
	// Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
	// for pre-defined dimension denotations.
	Denotation string `protobuf:"bytes,3,opt,name=denotation,proto3" json:"denotation,omitempty"`
}

func (m *TensorShapeProto_Dimension) Reset()         { *m = TensorShapeProto_Dimension{} }
func (m *TensorShapeProto_Dimension) String() string { return proto.CompactTextString(m) }
func (*TensorShapeProto_Dimension) ProtoMessage()    {}
func (*TensorShapeProto_Dimension) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{8, 0}
}
func (m *TensorShapeProto_Dimension) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TensorShapeProto_Dimension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TensorShapeProto_Dimension.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TensorShapeProto_Dimension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorShapeProto_Dimension.Merge(m, src)
}
func (m *TensorShapeProto_Dimension) XXX_Size() int {
	return m.Size()
}
func (m *TensorShapeProto_Dimension) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorShapeProto_Dimension.DiscardUnknown(m)
}

var xxx_messageInfo_TensorShapeProto_Dimension proto.InternalMessageInfo

type isTensorShapeProto_Dimension_Value interface {
	isTensorShapeProto_Dimension_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TensorShapeProto_Dimension_DimValue struct {
	DimValue int64 `protobuf:"varint,1,opt,name=dim_value,json=dimValue,proto3,oneof"`
}
type TensorShapeProto_Dimension_DimParam struct {
	DimParam string `protobuf:"bytes,2,opt,name=dim_param,json=dimParam,proto3,oneof"`
}

func (*TensorShapeProto_Dimension_DimValue) isTensorShapeProto_Dimension_Value() {}
func (*TensorShapeProto_Dimension_DimParam) isTensorShapeProto_Dimension_Value() {}

func (m *TensorShapeProto_Dimension) GetValue() isTensorShapeProto_Dimension_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TensorShapeProto_Dimension) GetDimValue() int64 {
	if x, ok := m.GetValue().(*TensorShapeProto_Dimension_DimValue); ok {
		return x.DimValue
	}
	return 0
}

func (m *TensorShapeProto_Dimension) GetDimParam() string {
	if x, ok := m.GetValue().(*TensorShapeProto_Dimension_DimParam); ok {
		return x.DimParam
	}
	return ""
}

func (m *TensorShapeProto_Dimension) GetDenotation() string {
	if m != nil {
		return m.Denotation
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TensorShapeProto_Dimension) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TensorShapeProto_Dimension_OneofMarshaler, _TensorShapeProto_Dimension_OneofUnmarshaler, _TensorShapeProto_Dimension_OneofSizer, []interface{}{
		(*TensorShapeProto_Dimension_DimValue)(nil),
		(*TensorShapeProto_Dimension_DimParam)(nil),
	}
}

func _TensorShapeProto_Dimension_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TensorShapeProto_Dimension)
	// value
	switch x := m.Value.(type) {
	case *TensorShapeProto_Dimension_DimValue:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.DimValue))
	case *TensorShapeProto_Dimension_DimParam:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.DimParam)
	case nil:
	default:
		return fmt.Errorf("TensorShapeProto_Dimension.Value has unexpected type %T", x)
	}
	return nil
}

func _TensorShapeProto_Dimension_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TensorShapeProto_Dimension)
	switch tag {
	case 1: // value.dim_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &TensorShapeProto_Dimension_DimValue{int64(x)}
		return true, err
	case 2: // value.dim_param
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &TensorShapeProto_Dimension_DimParam{x}
		return true, err
	default:
		return false, nil
	}
}

func _TensorShapeProto_Dimension_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TensorShapeProto_Dimension)
	// value
	switch x := m.Value.(type) {
	case *TensorShapeProto_Dimension_DimValue:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.DimValue))
	case *TensorShapeProto_Dimension_DimParam:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.DimParam)))
		n += len(x.DimParam)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Types
//
// The standard ONNX data types.
type TypeProto struct {
	// Types that are valid to be assigned to Value:
	//	*TypeProto_TensorType
	Value isTypeProto_Value `protobuf_oneof:"value"`
	// An optional denotation can be used to denote the whole
	// type with a standard semantic description as to what is
	// stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
	// for pre-defined type denotations.
	Denotation string `protobuf:"bytes,6,opt,name=denotation,proto3" json:"denotation,omitempty"`
}

func (m *TypeProto) Reset()         { *m = TypeProto{} }
func (m *TypeProto) String() string { return proto.CompactTextString(m) }
func (*TypeProto) ProtoMessage()    {}
func (*TypeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{9}
}
func (m *TypeProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeProto.Merge(m, src)
}
func (m *TypeProto) XXX_Size() int {
	return m.Size()
}
func (m *TypeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeProto.DiscardUnknown(m)
}

var xxx_messageInfo_TypeProto proto.InternalMessageInfo

type isTypeProto_Value interface {
	isTypeProto_Value()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TypeProto_TensorType struct {
	TensorType *TypeProto_Tensor `protobuf:"bytes,1,opt,name=tensor_type,json=tensorType,proto3,oneof"`
}

func (*TypeProto_TensorType) isTypeProto_Value() {}

func (m *TypeProto) GetValue() isTypeProto_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TypeProto) GetTensorType() *TypeProto_Tensor {
	if x, ok := m.GetValue().(*TypeProto_TensorType); ok {
		return x.TensorType
	}
	return nil
}

func (m *TypeProto) GetDenotation() string {
	if m != nil {
		return m.Denotation
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TypeProto) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TypeProto_OneofMarshaler, _TypeProto_OneofUnmarshaler, _TypeProto_OneofSizer, []interface{}{
		(*TypeProto_TensorType)(nil),
	}
}

func _TypeProto_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TypeProto)
	// value
	switch x := m.Value.(type) {
	case *TypeProto_TensorType:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TensorType); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TypeProto.Value has unexpected type %T", x)
	}
	return nil
}

func _TypeProto_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TypeProto)
	switch tag {
	case 1: // value.tensor_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeProto_Tensor)
		err := b.DecodeMessage(msg)
		m.Value = &TypeProto_TensorType{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TypeProto_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TypeProto)
	// value
	switch x := m.Value.(type) {
	case *TypeProto_TensorType:
		s := proto.Size(x.TensorType)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TypeProto_Tensor struct {
	// This field MUST NOT have the value of UNDEFINED
	// This field MUST have a valid TensorProto.DataType value
	// This field MUST be present for this version of the IR.
	ElemType int32             `protobuf:"varint,1,opt,name=elem_type,json=elemType,proto3" json:"elem_type,omitempty"`
	Shape    *TensorShapeProto `protobuf:"bytes,2,opt,name=shape,proto3" json:"shape,omitempty"`
}

func (m *TypeProto_Tensor) Reset()         { *m = TypeProto_Tensor{} }
func (m *TypeProto_Tensor) String() string { return proto.CompactTextString(m) }
func (*TypeProto_Tensor) ProtoMessage()    {}
func (*TypeProto_Tensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{9, 0}
}
func (m *TypeProto_Tensor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeProto_Tensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeProto_Tensor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeProto_Tensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeProto_Tensor.Merge(m, src)
}
func (m *TypeProto_Tensor) XXX_Size() int {
	return m.Size()
}
func (m *TypeProto_Tensor) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeProto_Tensor.DiscardUnknown(m)
}

var xxx_messageInfo_TypeProto_Tensor proto.InternalMessageInfo

func (m *TypeProto_Tensor) GetElemType() int32 {
	if m != nil {
		return m.ElemType
	}
	return 0
}

func (m *TypeProto_Tensor) GetShape() *TensorShapeProto {
	if m != nil {
		return m.Shape
	}
	return nil
}

// Operator Sets
//
// OperatorSets are uniquely identified by a (domain, opset_version) pair.
type OperatorSetIdProto struct {
	// The domain of the operator set being identified.
	// The empty string ("") or absence of this field implies the operator
	// set that is defined as part of the ONNX specification.
	// This field MUST be present in this version of the IR when referring to any other operator set.
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// The version of the operator set being identified.
	// This field MUST be present in this version of the IR.
	Version int64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *OperatorSetIdProto) Reset()         { *m = OperatorSetIdProto{} }
func (m *OperatorSetIdProto) String() string { return proto.CompactTextString(m) }
func (*OperatorSetIdProto) ProtoMessage()    {}
func (*OperatorSetIdProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{10}
}
func (m *OperatorSetIdProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorSetIdProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorSetIdProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorSetIdProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorSetIdProto.Merge(m, src)
}
func (m *OperatorSetIdProto) XXX_Size() int {
	return m.Size()
}
func (m *OperatorSetIdProto) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorSetIdProto.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorSetIdProto proto.InternalMessageInfo

func (m *OperatorSetIdProto) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *OperatorSetIdProto) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func init() {
	proto.RegisterEnum("onnx.Version", Version_name, Version_value)
	proto.RegisterEnum("onnx.AttributeProto_AttributeType", AttributeProto_AttributeType_name, AttributeProto_AttributeType_value)
	proto.RegisterEnum("onnx.TensorProto_DataType", TensorProto_DataType_name, TensorProto_DataType_value)
	proto.RegisterEnum("onnx.TensorProto_DataLocation", TensorProto_DataLocation_name, TensorProto_DataLocation_value)
	proto.RegisterType((*AttributeProto)(nil), "onnx.AttributeProto")
	proto.RegisterType((*ValueInfoProto)(nil), "onnx.ValueInfoProto")
	proto.RegisterType((*NodeProto)(nil), "onnx.NodeProto")
	proto.RegisterType((*ModelProto)(nil), "onnx.ModelProto")
	proto.RegisterType((*StringStringEntryProto)(nil), "onnx.StringStringEntryProto")
	proto.RegisterType((*TensorAnnotation)(nil), "onnx.TensorAnnotation")
	proto.RegisterType((*GraphProto)(nil), "onnx.GraphProto")
	proto.RegisterType((*TensorProto)(nil), "onnx.TensorProto")
	proto.RegisterType((*TensorProto_Segment)(nil), "onnx.TensorProto.Segment")
	proto.RegisterType((*TensorShapeProto)(nil), "onnx.TensorShapeProto")
	proto.RegisterType((*TensorShapeProto_Dimension)(nil), "onnx.TensorShapeProto.Dimension")
	proto.RegisterType((*TypeProto)(nil), "onnx.TypeProto")
	proto.RegisterType((*TypeProto_Tensor)(nil), "onnx.TypeProto.Tensor")
	proto.RegisterType((*OperatorSetIdProto)(nil), "onnx.OperatorSetIdProto")
}

func init() { proto.RegisterFile("onnx.proto3", fileDescriptor_d0206993eefcdc9e) }

var fileDescriptor_d0206993eefcdc9e = []byte{
	// 1587 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x57, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0xd7, 0x88, 0xfa, 0xc7, 0x47, 0x49, 0x99, 0x0e, 0xbc, 0x5e, 0xda, 0xdd, 0x28, 0xaa, 0x0c,
	0x14, 0xda, 0xed, 0xd6, 0x6b, 0x49, 0x86, 0x9a, 0x45, 0x2f, 0x95, 0x63, 0x39, 0x11, 0xe0, 0x95,
	0x0c, 0x4a, 0x0e, 0xf6, 0x52, 0x10, 0xb4, 0x49, 0xc9, 0x44, 0x25, 0x52, 0x25, 0x47, 0xd9, 0x38,
	0xb7, 0x7e, 0x83, 0xb6, 0x97, 0x7e, 0x85, 0x7e, 0x84, 0xa2, 0xbd, 0xf4, 0xd0, 0x43, 0x8f, 0xe9,
	0x2d, 0xe8, 0xa9, 0x75, 0xbe, 0x44, 0x7b, 0x2b, 0xe6, 0x0d, 0x49, 0x51, 0xb2, 0x93, 0xee, 0x45,
	0x98, 0xf7, 0xde, 0xef, 0x3d, 0xbe, 0x79, 0x7f, 0x47, 0xa0, 0xf9, 0x9e, 0xf7, 0xfa, 0x70, 0x19,
	0xf8, 0xdc, 0xef, 0xb0, 0x9c, 0x20, 0xf6, 0x7f, 0x3a, 0x73, 0xf9, 0xcd, 0xea, 0xea, 0xf0, 0xda,
	0x5f, 0x7c, 0x35, 0xf3, 0x67, 0xfe, 0x57, 0x28, 0xbd, 0x5a, 0x4d, 0x91, 0x42, 0x02, 0x4f, 0x52,
	0xab, 0xf1, 0x97, 0x1c, 0x54, 0x7b, 0x9c, 0x07, 0xee, 0xd5, 0x8a, 0x3b, 0x17, 0x82, 0xc5, 0x18,
	0xe4, 0x3c, 0x6b, 0xe1, 0xe8, 0xa4, 0x4e, 0x9a, 0xaa, 0x81, 0x67, 0xd6, 0x80, 0x4a, 0xe0, 0x4c,
	0x4d, 0x8b, 0xf3, 0xc0, 0x44, 0xe1, 0x27, 0x28, 0xd4, 0x02, 0x67, 0x2a, 0xb4, 0x87, 0x02, 0xf3,
	0x18, 0xc0, 0xf6, 0xaf, 0xcd, 0x90, 0x07, 0xae, 0x37, 0xd3, 0x2b, 0x08, 0x50, 0x6d, 0xff, 0x7a,
	0x8c, 0x0c, 0xd6, 0x85, 0x1c, 0xbf, 0x5d, 0x3a, 0xfa, 0x4e, 0x9d, 0x34, 0xab, 0xed, 0xc6, 0x21,
	0xba, 0xbe, 0xf9, 0xe9, 0x35, 0x39, 0xb9, 0x5d, 0x3a, 0x06, 0xe2, 0x59, 0x19, 0xc8, 0x54, 0xcf,
	0xd6, 0x49, 0x33, 0x6b, 0x90, 0xa9, 0xa0, 0x5c, 0x5d, 0xa9, 0x93, 0xa6, 0x62, 0x10, 0x57, 0x50,
	0xa1, 0x9e, 0xab, 0x93, 0x66, 0xd9, 0x20, 0x21, 0x7b, 0x02, 0x84, 0xeb, 0xf9, 0x3a, 0x69, 0x6a,
	0xed, 0x1f, 0x48, 0xf3, 0x13, 0xc7, 0x0b, 0xfd, 0x00, 0x6d, 0x1b, 0x84, 0xb3, 0x1a, 0x90, 0x99,
	0x5e, 0x40, 0x00, 0x95, 0x80, 0xe7, 0x81, 0xb5, 0xbc, 0x89, 0xe4, 0x33, 0xb6, 0x0b, 0x85, 0xe9,
	0xdc, 0xb7, 0x78, 0xa8, 0x17, 0xeb, 0x4a, 0x33, 0x6b, 0x44, 0x94, 0x88, 0x88, 0xeb, 0xf1, 0x50,
	0x2f, 0xd5, 0x95, 0xa6, 0x62, 0xe0, 0x99, 0xe9, 0x50, 0x94, 0x37, 0x0d, 0x75, 0xb5, 0xae, 0x34,
	0xcb, 0x46, 0x4c, 0xb2, 0x9f, 0x40, 0x91, 0xe3, 0x77, 0x43, 0x1d, 0xea, 0xca, 0xc3, 0xce, 0xc4,
	0x08, 0xd6, 0x84, 0xc2, 0x4c, 0xf8, 0x10, 0xea, 0x1a, 0x62, 0xef, 0xfb, 0x15, 0xc9, 0x1b, 0xbf,
	0x23, 0x50, 0xd9, 0x88, 0x0f, 0xab, 0x80, 0x7a, 0x39, 0x3c, 0xed, 0x9f, 0x0d, 0x86, 0xfd, 0x53,
	0x9a, 0x61, 0x2a, 0xe4, 0xcf, 0xce, 0x47, 0xbd, 0x09, 0x25, 0xac, 0x08, 0xca, 0x60, 0x38, 0xa1,
	0x59, 0x06, 0x50, 0x18, 0x4f, 0x8c, 0xc1, 0xf0, 0x39, 0x55, 0xc4, 0x79, 0xd2, 0x1f, 0x8e, 0x47,
	0x06, 0xcd, 0x09, 0xec, 0x73, 0xa3, 0x77, 0xf1, 0x82, 0xe6, 0x05, 0x1b, 0xd5, 0xc6, 0xb4, 0xc0,
	0x4a, 0x90, 0x1b, 0x0c, 0x27, 0x63, 0x5a, 0x64, 0x1a, 0x14, 0xa5, 0xe2, 0x98, 0x96, 0x04, 0x21,
	0x35, 0xc7, 0x54, 0x15, 0x78, 0x54, 0x1d, 0x53, 0x68, 0xdc, 0x40, 0xf5, 0xa5, 0x35, 0x5f, 0x39,
	0x03, 0x6f, 0xea, 0x7f, 0xb8, 0x78, 0x0e, 0xa2, 0xcc, 0x67, 0x31, 0xf2, 0x8f, 0xa2, 0x68, 0xdc,
	0x2e, 0x65, 0xd2, 0xa3, 0x34, 0x6f, 0x56, 0x8f, 0xb2, 0x55, 0x3d, 0x8d, 0x7f, 0x10, 0x50, 0x87,
	0xbe, 0x1d, 0x95, 0xe8, 0x0e, 0xe4, 0x5d, 0x6f, 0xb9, 0xe2, 0x3a, 0xa9, 0x2b, 0x4d, 0xd5, 0x90,
	0x84, 0x48, 0x9f, 0xbf, 0xe2, 0x82, 0x9d, 0x45, 0x76, 0x44, 0x25, 0x3e, 0x29, 0x29, 0x9f, 0x3e,
	0x85, 0xa2, 0xbf, 0x34, 0xd1, 0xad, 0x1c, 0xb2, 0x0b, 0xfe, 0x12, 0x83, 0xba, 0x0b, 0x05, 0xdb,
	0x5f, 0x58, 0xae, 0xa7, 0x17, 0x25, 0x5f, 0x52, 0xac, 0x0d, 0xaa, 0x15, 0x47, 0x5f, 0xcf, 0x63,
	0xae, 0x76, 0x1e, 0xaa, 0x61, 0x63, 0x0d, 0xdb, 0xba, 0x53, 0x61, 0xfb, 0x4e, 0xbf, 0x51, 0x00,
	0xbe, 0xf1, 0x6d, 0x67, 0x2e, 0x2f, 0xf5, 0x18, 0xc0, 0x0d, 0xcc, 0x57, 0x4e, 0x10, 0xba, 0xbe,
	0x87, 0x01, 0x54, 0x0c, 0xd5, 0x0d, 0x5e, 0x4a, 0x06, 0xfb, 0x39, 0x94, 0xfd, 0x65, 0xe8, 0x70,
	0xd3, 0x5d, 0x2c, 0xfd, 0x80, 0x63, 0x31, 0x6a, 0x6d, 0x5d, 0xfa, 0x30, 0x5a, 0x3a, 0x81, 0xc5,
	0xfd, 0x60, 0xec, 0xf0, 0x81, 0x2d, 0xfd, 0xd0, 0x10, 0x3d, 0x40, 0x30, 0x3b, 0x80, 0xca, 0x32,
	0xf0, 0xed, 0xd5, 0xb5, 0x13, 0xf5, 0x6f, 0x16, 0x9d, 0x29, 0xc7, 0x4c, 0x6c, 0xe0, 0xcf, 0x81,
	0x26, 0xa0, 0xd8, 0x0d, 0x19, 0xb3, 0x47, 0x31, 0x3f, 0x76, 0x66, 0x1d, 0xa5, 0xdc, 0x46, 0x94,
	0x0e, 0xa0, 0xb2, 0x10, 0x37, 0x4a, 0xf4, 0xf3, 0x78, 0x8d, 0x32, 0x32, 0x63, 0xe5, 0x8f, 0x87,
	0x85, 0xfd, 0x18, 0xf2, 0x58, 0xf2, 0x98, 0x80, 0x87, 0x3a, 0x42, 0x8a, 0xd9, 0x33, 0xa8, 0x2e,
	0x1c, 0x6e, 0xd9, 0x16, 0xb7, 0xcc, 0x65, 0xe0, 0x2f, 0x43, 0xbd, 0x8a, 0x21, 0xf9, 0x4c, 0x2a,
	0x48, 0x6b, 0xf2, 0xb7, 0xef, 0xf1, 0xe0, 0x56, 0x2a, 0x57, 0x62, 0x9d, 0x0b, 0xa1, 0xd2, 0xf8,
	0x05, 0xec, 0x3e, 0x0c, 0x64, 0x14, 0x94, 0x5f, 0x39, 0xb7, 0x51, 0x21, 0x8b, 0xa3, 0xa8, 0xba,
	0x57, 0xa2, 0xda, 0xa3, 0xe0, 0x49, 0xa2, 0xf1, 0x7b, 0x02, 0x54, 0xb6, 0x76, 0xcf, 0xf3, 0x7c,
	0x6e, 0x71, 0x71, 0xc5, 0x27, 0xa0, 0xc9, 0x0e, 0x37, 0x53, 0xdd, 0x00, 0x92, 0x85, 0xb1, 0xfe,
	0x25, 0x7c, 0xf6, 0xeb, 0x95, 0xe5, 0x71, 0x73, 0x69, 0x05, 0xd6, 0xc2, 0xe1, 0x4e, 0x60, 0xa6,
	0x14, 0x42, 0xac, 0xe0, 0xff, 0x77, 0x95, 0x3d, 0xb4, 0x70, 0x11, 0x1b, 0x98, 0x24, 0xd6, 0xc3,
	0xc6, 0x7f, 0xb3, 0x00, 0xeb, 0x88, 0x89, 0x0e, 0xf4, 0x7c, 0xdb, 0xc1, 0x76, 0x49, 0x3a, 0x30,
	0x69, 0x27, 0x03, 0x85, 0x49, 0x9b, 0x64, 0x53, 0x6d, 0xd2, 0x01, 0xcd, 0xf5, 0x5c, 0xee, 0x5a,
	0x73, 0xf7, 0x8d, 0x13, 0x44, 0x75, 0xff, 0xc0, 0x3c, 0x4b, 0xa3, 0xb6, 0xf2, 0x0b, 0xdb, 0xf9,
	0xfd, 0x22, 0x6e, 0x5e, 0x2d, 0xdd, 0x45, 0x9b, 0x73, 0x24, 0x6e, 0xe9, 0x2f, 0x93, 0x96, 0x2e,
	0x7f, 0x04, 0x1c, 0x37, 0x7a, 0x07, 0x00, 0x73, 0x62, 0xba, 0xde, 0xd4, 0xd7, 0x2b, 0x1f, 0xd1,
	0x50, 0x5f, 0xc5, 0x34, 0x1b, 0xc1, 0xa7, 0x18, 0x47, 0xf7, 0x0d, 0xa6, 0xce, 0xb4, 0x92, 0x2c,
	0x46, 0xf5, 0xb4, 0x9b, 0xbe, 0xee, 0x3a, 0xc7, 0xc6, 0x6e, 0x5a, 0x6d, 0xcd, 0x6f, 0xbc, 0x2b,
	0x80, 0x96, 0x8a, 0x8d, 0x88, 0xab, 0xed, 0x2e, 0x42, 0x0c, 0xbe, 0x62, 0xe0, 0x99, 0xfd, 0x10,
	0x54, 0xac, 0xdb, 0x64, 0x2e, 0xe6, 0x8d, 0x92, 0x60, 0xe0, 0x08, 0xea, 0x40, 0x31, 0x74, 0x66,
	0x0b, 0xc7, 0xe3, 0xd8, 0x7e, 0x5a, 0x7b, 0xef, 0x5e, 0xc0, 0x0f, 0xc7, 0x12, 0x60, 0xc4, 0x48,
	0xf6, 0x23, 0x00, 0xdc, 0x56, 0xa6, 0x30, 0xa3, 0xe7, 0xc4, 0xfe, 0x3a, 0xc9, 0x52, 0x62, 0xa8,
	0xc8, 0x3d, 0xb5, 0xb8, 0x25, 0x20, 0xae, 0xc7, 0x3b, 0x6d, 0x09, 0x11, 0xb9, 0xcc, 0x4b, 0x08,
	0x72, 0x11, 0xf2, 0x04, 0x34, 0x99, 0x36, 0x89, 0x29, 0xe0, 0x66, 0x03, 0xc9, 0x4a, 0xd9, 0xe8,
	0x1e, 0x4b, 0xb9, 0x58, 0x93, 0x4a, 0x62, 0xa3, 0x7b, 0x8c, 0x90, 0xb8, 0x8e, 0x4a, 0xa9, 0x3a,
	0xda, 0x2c, 0x89, 0xf2, 0x76, 0x49, 0xec, 0x41, 0x29, 0xb0, 0xbe, 0x93, 0x36, 0x55, 0x5c, 0xe7,
	0xc5, 0xc0, 0xfa, 0x0e, 0xad, 0xf5, 0xa0, 0xe2, 0xbc, 0xe6, 0x4e, 0xe0, 0x59, 0x73, 0x29, 0xaf,
	0x7c, 0x8f, 0xce, 0x28, 0xc7, 0x2a, 0x68, 0xe2, 0x19, 0x54, 0x30, 0xd8, 0x73, 0xff, 0x3a, 0xce,
	0xab, 0x78, 0x82, 0xd4, 0xee, 0x47, 0x55, 0xc0, 0xcf, 0x23, 0x94, 0x51, 0xb6, 0x53, 0x14, 0x3b,
	0x00, 0xcd, 0xf6, 0x57, 0x57, 0x73, 0x47, 0x7a, 0x21, 0x36, 0x3b, 0xc1, 0x9b, 0x83, 0x64, 0xe3,
	0x97, 0x0e, 0x40, 0x5b, 0xa5, 0xc2, 0x23, 0x0a, 0x3c, 0x27, 0x41, 0xab, 0x24, 0x3e, 0xfb, 0x2d,
	0x28, 0x46, 0xd9, 0x13, 0x13, 0xe5, 0xca, 0x99, 0xb9, 0xf1, 0xb4, 0x97, 0x84, 0x98, 0x3c, 0x8e,
	0x67, 0x63, 0x59, 0x28, 0x86, 0x38, 0x36, 0xfe, 0x49, 0xa0, 0x74, 0x1a, 0x97, 0xc7, 0x87, 0xd7,
	0xbe, 0x0a, 0xf9, 0xcb, 0xc1, 0x70, 0xf2, 0x94, 0x66, 0xa3, 0x4d, 0xfe, 0x54, 0xae, 0x7d, 0xc1,
	0x6c, 0x75, 0xe5, 0xda, 0x97, 0xc7, 0x7c, 0x74, 0xec, 0xb4, 0x69, 0x21, 0x3a, 0x76, 0x8f, 0x69,
	0x31, 0xf5, 0x5e, 0x28, 0x09, 0x13, 0x27, 0xa3, 0xd1, 0x39, 0x55, 0xc5, 0xfe, 0xc7, 0x4f, 0xb4,
	0xba, 0x14, 0x04, 0xe4, 0x74, 0x74, 0x79, 0x72, 0xde, 0xa7, 0x5a, 0x6c, 0xbb, 0xd3, 0xa6, 0xe5,
	0xf8, 0xdc, 0x3d, 0xa6, 0x15, 0xe1, 0xe2, 0xb3, 0xd1, 0x37, 0x17, 0xe7, 0xfd, 0x6f, 0xbb, 0xc7,
	0xb4, 0xca, 0xaa, 0x00, 0x11, 0xd9, 0x6a, 0x3f, 0xa5, 0x8f, 0x58, 0x19, 0x4a, 0x27, 0xb1, 0x41,
	0xda, 0xf8, 0x1c, 0xca, 0xe9, 0xb8, 0x8b, 0xaf, 0x9d, 0xf6, 0xcf, 0x7a, 0x97, 0xe7, 0x13, 0x9a,
	0x11, 0xd0, 0xfe, 0xb7, 0x93, 0xbe, 0x31, 0xec, 0x9d, 0x53, 0xd2, 0xf8, 0x73, 0x32, 0x6b, 0xc7,
	0x37, 0x56, 0xf4, 0x7e, 0x60, 0x6d, 0x50, 0x6c, 0x77, 0x11, 0xcd, 0xb6, 0x7a, 0x3a, 0xa9, 0x6b,
	0xd0, 0xe1, 0xa9, 0xbb, 0x70, 0x3c, 0xb1, 0x7d, 0x0c, 0x01, 0xde, 0x0f, 0x40, 0x4d, 0x38, 0xec,
	0x31, 0xa8, 0xb6, 0xbb, 0x30, 0xe5, 0x6c, 0xc7, 0x4c, 0xbc, 0xc8, 0x18, 0x25, 0xdb, 0x5d, 0xe0,
	0xd0, 0x88, 0xc5, 0x38, 0xa8, 0xe5, 0x70, 0x8c, 0xc4, 0x38, 0x79, 0x59, 0x0d, 0xc0, 0x76, 0x92,
	0x91, 0x21, 0xf7, 0x65, 0x8a, 0x73, 0x52, 0x8c, 0xb6, 0x46, 0xe3, 0x6f, 0x04, 0xd4, 0xe4, 0xd5,
	0xc3, 0xbe, 0x4e, 0x36, 0x04, 0xce, 0x00, 0x82, 0x8d, 0xbe, 0xbb, 0xf5, 0x36, 0x8a, 0xee, 0xf1,
	0x22, 0x13, 0xef, 0x0e, 0x2c, 0x80, 0xcd, 0x2f, 0x16, 0xb6, 0xbf, 0xb8, 0x3f, 0x86, 0x82, 0xd4,
	0x13, 0x63, 0xc6, 0x99, 0x3b, 0x8b, 0xf5, 0x27, 0xf2, 0x46, 0x49, 0x30, 0xd0, 0xcc, 0x97, 0x90,
	0x0f, 0x45, 0x80, 0xa2, 0x77, 0xd9, 0xee, 0xc3, 0x91, 0x33, 0x24, 0x68, 0x7d, 0x8d, 0x33, 0x60,
	0xf7, 0x5f, 0x1b, 0xa9, 0x07, 0x01, 0xd9, 0x78, 0x10, 0xe8, 0x50, 0x8c, 0x9f, 0x02, 0xb2, 0x9e,
	0x63, 0xf2, 0x8b, 0x3f, 0x10, 0x28, 0xc6, 0x2f, 0x02, 0x06, 0x55, 0x73, 0x3c, 0xe9, 0x19, 0x13,
	0xf3, 0x65, 0xdf, 0x18, 0x0f, 0x46, 0x43, 0x9a, 0x61, 0x7b, 0xf0, 0xc9, 0xc0, 0x88, 0x69, 0xb3,
	0x7d, 0xd4, 0xfa, 0x99, 0xd9, 0x3a, 0x32, 0x5b, 0x47, 0x94, 0x7c, 0x40, 0xd4, 0x39, 0xa2, 0x59,
	0xa6, 0xc3, 0xce, 0x3d, 0x51, 0xcb, 0xec, 0x50, 0xe5, 0xbe, 0xe4, 0x6b, 0xb3, 0x65, 0xb6, 0xdb,
	0x34, 0x27, 0xca, 0x73, 0x2d, 0xa1, 0xf9, 0x93, 0xe6, 0x7f, 0xfe, 0x5d, 0x23, 0x7f, 0xbc, 0xab,
	0x91, 0x3f, 0xdd, 0xd5, 0xc8, 0x5f, 0xef, 0x6a, 0xe4, 0xef, 0x77, 0x35, 0xf2, 0xf6, 0xae, 0x46,
	0xfe, 0x75, 0x57, 0x23, 0xbf, 0x7d, 0x5f, 0xcb, 0xbc, 0x7d, 0x5f, 0xcb, 0xbc, 0x7b, 0x5f, 0xcb,
	0x5c, 0x15, 0xe4, 0x5f, 0xaf, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x70, 0xd1, 0xb5, 0xc8, 0x88,
	0x0d, 0x00, 0x00,
}

func (this *AttributeProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttributeProto)
	if !ok {
		that2, ok := that.(AttributeProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.RefAttrName != that1.RefAttrName {
		return false
	}
	if this.DocString != that1.DocString {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.F != that1.F {
		return false
	}
	if this.I != that1.I {
		return false
	}
	if !bytes.Equal(this.S, that1.S) {
		return false
	}
	if !this.T.Equal(that1.T) {
		return false
	}
	if !this.G.Equal(that1.G) {
		return false
	}
	if len(this.Floats) != len(that1.Floats) {
		return false
	}
	for i := range this.Floats {
		if this.Floats[i] != that1.Floats[i] {
			return false
		}
	}
	if len(this.Ints) != len(that1.Ints) {
		return false
	}
	for i := range this.Ints {
		if this.Ints[i] != that1.Ints[i] {
			return false
		}
	}
	if len(this.Strings) != len(that1.Strings) {
		return false
	}
	for i := range this.Strings {
		if !bytes.Equal(this.Strings[i], that1.Strings[i]) {
			return false
		}
	}
	if len(this.Tensors) != len(that1.Tensors) {
		return false
	}
	for i := range this.Tensors {
		if !this.Tensors[i].Equal(that1.Tensors[i]) {
			return false
		}
	}
	if len(this.Graphs) != len(that1.Graphs) {
		return false
	}
	for i := range this.Graphs {
		if !this.Graphs[i].Equal(that1.Graphs[i]) {
			return false
		}
	}
	return true
}
func (this *ValueInfoProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValueInfoProto)
	if !ok {
		that2, ok := that.(ValueInfoProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Type.Equal(that1.Type) {
		return false
	}
	if this.DocString != that1.DocString {
		return false
	}
	return true
}
func (this *NodeProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeProto)
	if !ok {
		that2, ok := that.(NodeProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Input) != len(that1.Input) {
		return false
	}
	for i := range this.Input {
		if this.Input[i] != that1.Input[i] {
			return false
		}
	}
	if len(this.Output) != len(that1.Output) {
		return false
	}
	for i := range this.Output {
		if this.Output[i] != that1.Output[i] {
			return false
		}
	}
	if this.Name != that1.Name {
		return false
	}
	if this.OpType != that1.OpType {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if len(this.Attribute) != len(that1.Attribute) {
		return false
	}
	for i := range this.Attribute {
		if !this.Attribute[i].Equal(that1.Attribute[i]) {
			return false
		}
	}
	if this.DocString != that1.DocString {
		return false
	}
	return true
}
func (this *ModelProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelProto)
	if !ok {
		that2, ok := that.(ModelProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IrVersion != that1.IrVersion {
		return false
	}
	if len(this.OpsetImport) != len(that1.OpsetImport) {
		return false
	}
	for i := range this.OpsetImport {
		if !this.OpsetImport[i].Equal(that1.OpsetImport[i]) {
			return false
		}
	}
	if this.ProducerName != that1.ProducerName {
		return false
	}
	if this.ProducerVersion != that1.ProducerVersion {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.ModelVersion != that1.ModelVersion {
		return false
	}
	if this.DocString != that1.DocString {
		return false
	}
	if !this.Graph.Equal(that1.Graph) {
		return false
	}
	if len(this.MetadataProps) != len(that1.MetadataProps) {
		return false
	}
	for i := range this.MetadataProps {
		if !this.MetadataProps[i].Equal(that1.MetadataProps[i]) {
			return false
		}
	}
	return true
}
func (this *StringStringEntryProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StringStringEntryProto)
	if !ok {
		that2, ok := that.(StringStringEntryProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *TensorAnnotation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorAnnotation)
	if !ok {
		that2, ok := that.(TensorAnnotation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TensorName != that1.TensorName {
		return false
	}
	if len(this.QuantParameterTensorNames) != len(that1.QuantParameterTensorNames) {
		return false
	}
	for i := range this.QuantParameterTensorNames {
		if !this.QuantParameterTensorNames[i].Equal(that1.QuantParameterTensorNames[i]) {
			return false
		}
	}
	return true
}
func (this *GraphProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GraphProto)
	if !ok {
		that2, ok := that.(GraphProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Node) != len(that1.Node) {
		return false
	}
	for i := range this.Node {
		if !this.Node[i].Equal(that1.Node[i]) {
			return false
		}
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Initializer) != len(that1.Initializer) {
		return false
	}
	for i := range this.Initializer {
		if !this.Initializer[i].Equal(that1.Initializer[i]) {
			return false
		}
	}
	if this.DocString != that1.DocString {
		return false
	}
	if len(this.Input) != len(that1.Input) {
		return false
	}
	for i := range this.Input {
		if !this.Input[i].Equal(that1.Input[i]) {
			return false
		}
	}
	if len(this.Output) != len(that1.Output) {
		return false
	}
	for i := range this.Output {
		if !this.Output[i].Equal(that1.Output[i]) {
			return false
		}
	}
	if len(this.ValueInfo) != len(that1.ValueInfo) {
		return false
	}
	for i := range this.ValueInfo {
		if !this.ValueInfo[i].Equal(that1.ValueInfo[i]) {
			return false
		}
	}
	if len(this.QuantizationAnnotation) != len(that1.QuantizationAnnotation) {
		return false
	}
	for i := range this.QuantizationAnnotation {
		if !this.QuantizationAnnotation[i].Equal(that1.QuantizationAnnotation[i]) {
			return false
		}
	}
	return true
}
func (this *TensorProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorProto)
	if !ok {
		that2, ok := that.(TensorProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Dims) != len(that1.Dims) {
		return false
	}
	for i := range this.Dims {
		if this.Dims[i] != that1.Dims[i] {
			return false
		}
	}
	if this.DataType != that1.DataType {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	if len(this.FloatData) != len(that1.FloatData) {
		return false
	}
	for i := range this.FloatData {
		if this.FloatData[i] != that1.FloatData[i] {
			return false
		}
	}
	if len(this.Int32Data) != len(that1.Int32Data) {
		return false
	}
	for i := range this.Int32Data {
		if this.Int32Data[i] != that1.Int32Data[i] {
			return false
		}
	}
	if len(this.StringData) != len(that1.StringData) {
		return false
	}
	for i := range this.StringData {
		if !bytes.Equal(this.StringData[i], that1.StringData[i]) {
			return false
		}
	}
	if len(this.Int64Data) != len(that1.Int64Data) {
		return false
	}
	for i := range this.Int64Data {
		if this.Int64Data[i] != that1.Int64Data[i] {
			return false
		}
	}
	if this.Name != that1.Name {
		return false
	}
	if this.DocString != that1.DocString {
		return false
	}
	if !bytes.Equal(this.RawData, that1.RawData) {
		return false
	}
	if len(this.ExternalData) != len(that1.ExternalData) {
		return false
	}
	for i := range this.ExternalData {
		if !this.ExternalData[i].Equal(that1.ExternalData[i]) {
			return false
		}
	}
	if this.DataLocation != that1.DataLocation {
		return false
	}
	if len(this.DoubleData) != len(that1.DoubleData) {
		return false
	}
	for i := range this.DoubleData {
		if this.DoubleData[i] != that1.DoubleData[i] {
			return false
		}
	}
	if len(this.Uint64Data) != len(that1.Uint64Data) {
		return false
	}
	for i := range this.Uint64Data {
		if this.Uint64Data[i] != that1.Uint64Data[i] {
			return false
		}
	}
	return true
}
func (this *TensorProto_Segment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorProto_Segment)
	if !ok {
		that2, ok := that.(TensorProto_Segment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Begin != that1.Begin {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *TensorShapeProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorShapeProto)
	if !ok {
		that2, ok := that.(TensorShapeProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Dim) != len(that1.Dim) {
		return false
	}
	for i := range this.Dim {
		if !this.Dim[i].Equal(that1.Dim[i]) {
			return false
		}
	}
	return true
}
func (this *TensorShapeProto_Dimension) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorShapeProto_Dimension)
	if !ok {
		that2, ok := that.(TensorShapeProto_Dimension)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	if this.Denotation != that1.Denotation {
		return false
	}
	return true
}
func (this *TensorShapeProto_Dimension_DimValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorShapeProto_Dimension_DimValue)
	if !ok {
		that2, ok := that.(TensorShapeProto_Dimension_DimValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DimValue != that1.DimValue {
		return false
	}
	return true
}
func (this *TensorShapeProto_Dimension_DimParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TensorShapeProto_Dimension_DimParam)
	if !ok {
		that2, ok := that.(TensorShapeProto_Dimension_DimParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DimParam != that1.DimParam {
		return false
	}
	return true
}
func (this *TypeProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TypeProto)
	if !ok {
		that2, ok := that.(TypeProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Value == nil {
		if this.Value != nil {
			return false
		}
	} else if this.Value == nil {
		return false
	} else if !this.Value.Equal(that1.Value) {
		return false
	}
	if this.Denotation != that1.Denotation {
		return false
	}
	return true
}
func (this *TypeProto_TensorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TypeProto_TensorType)
	if !ok {
		that2, ok := that.(TypeProto_TensorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TensorType.Equal(that1.TensorType) {
		return false
	}
	return true
}
func (this *TypeProto_Tensor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TypeProto_Tensor)
	if !ok {
		that2, ok := that.(TypeProto_Tensor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ElemType != that1.ElemType {
		return false
	}
	if !this.Shape.Equal(that1.Shape) {
		return false
	}
	return true
}
func (this *OperatorSetIdProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OperatorSetIdProto)
	if !ok {
		that2, ok := that.(OperatorSetIdProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (m *AttributeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.F != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.F))))
		i += 4
	}
	if m.I != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.I))
	}
	if len(m.S) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.S)))
		i += copy(dAtA[i:], m.S)
	}
	if m.T != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.T.Size()))
		n1, err := m.T.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.G != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.G.Size()))
		n2, err := m.G.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Floats) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Floats)*4))
		for _, num := range m.Floats {
			f3 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f3))
			i += 4
		}
	}
	if len(m.Ints) > 0 {
		dAtA5 := make([]byte, len(m.Ints)*10)
		var j4 int
		for _, num1 := range m.Ints {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.Strings) > 0 {
		for _, b := range m.Strings {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Tensors) > 0 {
		for _, msg := range m.Tensors {
			dAtA[i] = 0x52
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Graphs) > 0 {
		for _, msg := range m.Graphs {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DocString) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.DocString)))
		i += copy(dAtA[i:], m.DocString)
	}
	if m.Type != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.Type))
	}
	if len(m.RefAttrName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.RefAttrName)))
		i += copy(dAtA[i:], m.RefAttrName)
	}
	return i, nil
}

func (m *ValueInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Type != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.Type.Size()))
		n6, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.DocString) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.DocString)))
		i += copy(dAtA[i:], m.DocString)
	}
	return i, nil
}

func (m *NodeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, s := range m.Input {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Output) > 0 {
		for _, s := range m.Output {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.OpType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.OpType)))
		i += copy(dAtA[i:], m.OpType)
	}
	if len(m.Attribute) > 0 {
		for _, msg := range m.Attribute {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DocString) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.DocString)))
		i += copy(dAtA[i:], m.DocString)
	}
	if len(m.Domain) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Domain)))
		i += copy(dAtA[i:], m.Domain)
	}
	return i, nil
}

func (m *ModelProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IrVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.IrVersion))
	}
	if len(m.ProducerName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.ProducerName)))
		i += copy(dAtA[i:], m.ProducerName)
	}
	if len(m.ProducerVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.ProducerVersion)))
		i += copy(dAtA[i:], m.ProducerVersion)
	}
	if len(m.Domain) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Domain)))
		i += copy(dAtA[i:], m.Domain)
	}
	if m.ModelVersion != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.ModelVersion))
	}
	if len(m.DocString) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.DocString)))
		i += copy(dAtA[i:], m.DocString)
	}
	if m.Graph != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.Graph.Size()))
		n7, err := m.Graph.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.OpsetImport) > 0 {
		for _, msg := range m.OpsetImport {
			dAtA[i] = 0x42
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetadataProps) > 0 {
		for _, msg := range m.MetadataProps {
			dAtA[i] = 0x72
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StringStringEntryProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringStringEntryProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *TensorAnnotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorAnnotation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TensorName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.TensorName)))
		i += copy(dAtA[i:], m.TensorName)
	}
	if len(m.QuantParameterTensorNames) > 0 {
		for _, msg := range m.QuantParameterTensorNames {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GraphProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Node) > 0 {
		for _, msg := range m.Node {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Initializer) > 0 {
		for _, msg := range m.Initializer {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DocString) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.DocString)))
		i += copy(dAtA[i:], m.DocString)
	}
	if len(m.Input) > 0 {
		for _, msg := range m.Input {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Output) > 0 {
		for _, msg := range m.Output {
			dAtA[i] = 0x62
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ValueInfo) > 0 {
		for _, msg := range m.ValueInfo {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.QuantizationAnnotation) > 0 {
		for _, msg := range m.QuantizationAnnotation {
			dAtA[i] = 0x72
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TensorProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dims) > 0 {
		dAtA9 := make([]byte, len(m.Dims)*10)
		var j8 int
		for _, num1 := range m.Dims {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if m.DataType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.DataType))
	}
	if m.Segment != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.Segment.Size()))
		n10, err := m.Segment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.FloatData) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.FloatData)*4))
		for _, num := range m.FloatData {
			f11 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f11))
			i += 4
		}
	}
	if len(m.Int32Data) > 0 {
		dAtA13 := make([]byte, len(m.Int32Data)*10)
		var j12 int
		for _, num1 := range m.Int32Data {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	if len(m.StringData) > 0 {
		for _, b := range m.StringData {
			dAtA[i] = 0x32
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Int64Data) > 0 {
		dAtA15 := make([]byte, len(m.Int64Data)*10)
		var j14 int
		for _, num1 := range m.Int64Data {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.RawData) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.RawData)))
		i += copy(dAtA[i:], m.RawData)
	}
	if len(m.DoubleData) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.DoubleData)*8))
		for _, num := range m.DoubleData {
			f16 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f16))
			i += 8
		}
	}
	if len(m.Uint64Data) > 0 {
		dAtA18 := make([]byte, len(m.Uint64Data)*10)
		var j17 int
		for _, num := range m.Uint64Data {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if len(m.DocString) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.DocString)))
		i += copy(dAtA[i:], m.DocString)
	}
	if len(m.ExternalData) > 0 {
		for _, msg := range m.ExternalData {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DataLocation != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.DataLocation))
	}
	return i, nil
}

func (m *TensorProto_Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorProto_Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Begin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.Begin))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *TensorShapeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorShapeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dim) > 0 {
		for _, msg := range m.Dim {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOnnx3(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TensorShapeProto_Dimension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorShapeProto_Dimension) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn19, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn19
	}
	if len(m.Denotation) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Denotation)))
		i += copy(dAtA[i:], m.Denotation)
	}
	return i, nil
}

func (m *TensorShapeProto_Dimension_DimValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintOnnx3(dAtA, i, uint64(m.DimValue))
	return i, nil
}
func (m *TensorShapeProto_Dimension_DimParam) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintOnnx3(dAtA, i, uint64(len(m.DimParam)))
	i += copy(dAtA[i:], m.DimParam)
	return i, nil
}
func (m *TypeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn20, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	if len(m.Denotation) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Denotation)))
		i += copy(dAtA[i:], m.Denotation)
	}
	return i, nil
}

func (m *TypeProto_TensorType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TensorType != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.TensorType.Size()))
		n21, err := m.TensorType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *TypeProto_Tensor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeProto_Tensor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ElemType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.ElemType))
	}
	if m.Shape != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.Shape.Size()))
		n22, err := m.Shape.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *OperatorSetIdProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorSetIdProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Domain) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(len(m.Domain)))
		i += copy(dAtA[i:], m.Domain)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOnnx3(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func encodeVarintOnnx3(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedAttributeProto(r randyOnnx3, easy bool) *AttributeProto {
	this := &AttributeProto{}
	this.Name = string(randStringOnnx3(r))
	this.F = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.F *= -1
	}
	this.I = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.I *= -1
	}
	v1 := r.Intn(100)
	this.S = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.S[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		this.T = NewPopulatedTensorProto(r, easy)
	}
	if r.Intn(10) == 0 {
		this.G = NewPopulatedGraphProto(r, easy)
	}
	v2 := r.Intn(10)
	this.Floats = make([]float32, v2)
	for i := 0; i < v2; i++ {
		this.Floats[i] = float32(r.Float32())
		if r.Intn(2) == 0 {
			this.Floats[i] *= -1
		}
	}
	v3 := r.Intn(10)
	this.Ints = make([]int64, v3)
	for i := 0; i < v3; i++ {
		this.Ints[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.Ints[i] *= -1
		}
	}
	v4 := r.Intn(10)
	this.Strings = make([][]byte, v4)
	for i := 0; i < v4; i++ {
		v5 := r.Intn(100)
		this.Strings[i] = make([]byte, v5)
		for j := 0; j < v5; j++ {
			this.Strings[i][j] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.Tensors = make([]*TensorProto, v6)
		for i := 0; i < v6; i++ {
			this.Tensors[i] = NewPopulatedTensorProto(r, easy)
		}
	}
	if r.Intn(10) == 0 {
		v7 := r.Intn(5)
		this.Graphs = make([]*GraphProto, v7)
		for i := 0; i < v7; i++ {
			this.Graphs[i] = NewPopulatedGraphProto(r, easy)
		}
	}
	this.DocString = string(randStringOnnx3(r))
	this.Type = AttributeProto_AttributeType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}[r.Intn(11)])
	this.RefAttrName = string(randStringOnnx3(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedValueInfoProto(r randyOnnx3, easy bool) *ValueInfoProto {
	this := &ValueInfoProto{}
	this.Name = string(randStringOnnx3(r))
	if r.Intn(10) != 0 {
		this.Type = NewPopulatedTypeProto(r, easy)
	}
	this.DocString = string(randStringOnnx3(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNodeProto(r randyOnnx3, easy bool) *NodeProto {
	this := &NodeProto{}
	v8 := r.Intn(10)
	this.Input = make([]string, v8)
	for i := 0; i < v8; i++ {
		this.Input[i] = string(randStringOnnx3(r))
	}
	v9 := r.Intn(10)
	this.Output = make([]string, v9)
	for i := 0; i < v9; i++ {
		this.Output[i] = string(randStringOnnx3(r))
	}
	this.Name = string(randStringOnnx3(r))
	this.OpType = string(randStringOnnx3(r))
	if r.Intn(10) == 0 {
		v10 := r.Intn(5)
		this.Attribute = make([]*AttributeProto, v10)
		for i := 0; i < v10; i++ {
			this.Attribute[i] = NewPopulatedAttributeProto(r, easy)
		}
	}
	this.DocString = string(randStringOnnx3(r))
	this.Domain = string(randStringOnnx3(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedModelProto(r randyOnnx3, easy bool) *ModelProto {
	this := &ModelProto{}
	this.IrVersion = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.IrVersion *= -1
	}
	this.ProducerName = string(randStringOnnx3(r))
	this.ProducerVersion = string(randStringOnnx3(r))
	this.Domain = string(randStringOnnx3(r))
	this.ModelVersion = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ModelVersion *= -1
	}
	this.DocString = string(randStringOnnx3(r))
	if r.Intn(10) == 0 {
		this.Graph = NewPopulatedGraphProto(r, easy)
	}
	if r.Intn(10) != 0 {
		v11 := r.Intn(5)
		this.OpsetImport = make([]*OperatorSetIdProto, v11)
		for i := 0; i < v11; i++ {
			this.OpsetImport[i] = NewPopulatedOperatorSetIdProto(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.MetadataProps = make([]*StringStringEntryProto, v12)
		for i := 0; i < v12; i++ {
			this.MetadataProps[i] = NewPopulatedStringStringEntryProto(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStringStringEntryProto(r randyOnnx3, easy bool) *StringStringEntryProto {
	this := &StringStringEntryProto{}
	this.Key = string(randStringOnnx3(r))
	this.Value = string(randStringOnnx3(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTensorAnnotation(r randyOnnx3, easy bool) *TensorAnnotation {
	this := &TensorAnnotation{}
	this.TensorName = string(randStringOnnx3(r))
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.QuantParameterTensorNames = make([]*StringStringEntryProto, v13)
		for i := 0; i < v13; i++ {
			this.QuantParameterTensorNames[i] = NewPopulatedStringStringEntryProto(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGraphProto(r randyOnnx3, easy bool) *GraphProto {
	this := &GraphProto{}
	if r.Intn(10) == 0 {
		v14 := r.Intn(5)
		this.Node = make([]*NodeProto, v14)
		for i := 0; i < v14; i++ {
			this.Node[i] = NewPopulatedNodeProto(r, easy)
		}
	}
	this.Name = string(randStringOnnx3(r))
	if r.Intn(10) != 0 {
		v15 := r.Intn(5)
		this.Initializer = make([]*TensorProto, v15)
		for i := 0; i < v15; i++ {
			this.Initializer[i] = NewPopulatedTensorProto(r, easy)
		}
	}
	this.DocString = string(randStringOnnx3(r))
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.Input = make([]*ValueInfoProto, v16)
		for i := 0; i < v16; i++ {
			this.Input[i] = NewPopulatedValueInfoProto(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v17 := r.Intn(5)
		this.Output = make([]*ValueInfoProto, v17)
		for i := 0; i < v17; i++ {
			this.Output[i] = NewPopulatedValueInfoProto(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.ValueInfo = make([]*ValueInfoProto, v18)
		for i := 0; i < v18; i++ {
			this.ValueInfo[i] = NewPopulatedValueInfoProto(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v19 := r.Intn(5)
		this.QuantizationAnnotation = make([]*TensorAnnotation, v19)
		for i := 0; i < v19; i++ {
			this.QuantizationAnnotation[i] = NewPopulatedTensorAnnotation(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTensorProto(r randyOnnx3, easy bool) *TensorProto {
	this := &TensorProto{}
	v20 := r.Intn(10)
	this.Dims = make([]int64, v20)
	for i := 0; i < v20; i++ {
		this.Dims[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.Dims[i] *= -1
		}
	}
	this.DataType = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.DataType *= -1
	}
	if r.Intn(10) != 0 {
		this.Segment = NewPopulatedTensorProto_Segment(r, easy)
	}
	v21 := r.Intn(10)
	this.FloatData = make([]float32, v21)
	for i := 0; i < v21; i++ {
		this.FloatData[i] = float32(r.Float32())
		if r.Intn(2) == 0 {
			this.FloatData[i] *= -1
		}
	}
	v22 := r.Intn(10)
	this.Int32Data = make([]int32, v22)
	for i := 0; i < v22; i++ {
		this.Int32Data[i] = int32(r.Int31())
		if r.Intn(2) == 0 {
			this.Int32Data[i] *= -1
		}
	}
	v23 := r.Intn(10)
	this.StringData = make([][]byte, v23)
	for i := 0; i < v23; i++ {
		v24 := r.Intn(100)
		this.StringData[i] = make([]byte, v24)
		for j := 0; j < v24; j++ {
			this.StringData[i][j] = byte(r.Intn(256))
		}
	}
	v25 := r.Intn(10)
	this.Int64Data = make([]int64, v25)
	for i := 0; i < v25; i++ {
		this.Int64Data[i] = int64(r.Int63())
		if r.Intn(2) == 0 {
			this.Int64Data[i] *= -1
		}
	}
	this.Name = string(randStringOnnx3(r))
	v26 := r.Intn(100)
	this.RawData = make([]byte, v26)
	for i := 0; i < v26; i++ {
		this.RawData[i] = byte(r.Intn(256))
	}
	v27 := r.Intn(10)
	this.DoubleData = make([]float64, v27)
	for i := 0; i < v27; i++ {
		this.DoubleData[i] = float64(r.Float64())
		if r.Intn(2) == 0 {
			this.DoubleData[i] *= -1
		}
	}
	v28 := r.Intn(10)
	this.Uint64Data = make([]uint64, v28)
	for i := 0; i < v28; i++ {
		this.Uint64Data[i] = uint64(uint64(r.Uint32()))
	}
	this.DocString = string(randStringOnnx3(r))
	if r.Intn(10) != 0 {
		v29 := r.Intn(5)
		this.ExternalData = make([]*StringStringEntryProto, v29)
		for i := 0; i < v29; i++ {
			this.ExternalData[i] = NewPopulatedStringStringEntryProto(r, easy)
		}
	}
	this.DataLocation = TensorProto_DataLocation([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTensorProto_Segment(r randyOnnx3, easy bool) *TensorProto_Segment {
	this := &TensorProto_Segment{}
	this.Begin = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Begin *= -1
	}
	this.End = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.End *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTensorShapeProto(r randyOnnx3, easy bool) *TensorShapeProto {
	this := &TensorShapeProto{}
	if r.Intn(10) != 0 {
		v30 := r.Intn(5)
		this.Dim = make([]*TensorShapeProto_Dimension, v30)
		for i := 0; i < v30; i++ {
			this.Dim[i] = NewPopulatedTensorShapeProto_Dimension(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTensorShapeProto_Dimension(r randyOnnx3, easy bool) *TensorShapeProto_Dimension {
	this := &TensorShapeProto_Dimension{}
	oneofNumber_Value := []int32{1, 2}[r.Intn(2)]
	switch oneofNumber_Value {
	case 1:
		this.Value = NewPopulatedTensorShapeProto_Dimension_DimValue(r, easy)
	case 2:
		this.Value = NewPopulatedTensorShapeProto_Dimension_DimParam(r, easy)
	}
	this.Denotation = string(randStringOnnx3(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTensorShapeProto_Dimension_DimValue(r randyOnnx3, easy bool) *TensorShapeProto_Dimension_DimValue {
	this := &TensorShapeProto_Dimension_DimValue{}
	this.DimValue = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.DimValue *= -1
	}
	return this
}
func NewPopulatedTensorShapeProto_Dimension_DimParam(r randyOnnx3, easy bool) *TensorShapeProto_Dimension_DimParam {
	this := &TensorShapeProto_Dimension_DimParam{}
	this.DimParam = string(randStringOnnx3(r))
	return this
}
func NewPopulatedTypeProto(r randyOnnx3, easy bool) *TypeProto {
	this := &TypeProto{}
	oneofNumber_Value := []int32{1}[r.Intn(1)]
	switch oneofNumber_Value {
	case 1:
		this.Value = NewPopulatedTypeProto_TensorType(r, easy)
	}
	this.Denotation = string(randStringOnnx3(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTypeProto_TensorType(r randyOnnx3, easy bool) *TypeProto_TensorType {
	this := &TypeProto_TensorType{}
	this.TensorType = NewPopulatedTypeProto_Tensor(r, easy)
	return this
}
func NewPopulatedTypeProto_Tensor(r randyOnnx3, easy bool) *TypeProto_Tensor {
	this := &TypeProto_Tensor{}
	this.ElemType = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ElemType *= -1
	}
	if r.Intn(10) != 0 {
		this.Shape = NewPopulatedTensorShapeProto(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOperatorSetIdProto(r randyOnnx3, easy bool) *OperatorSetIdProto {
	this := &OperatorSetIdProto{}
	this.Domain = string(randStringOnnx3(r))
	this.Version = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Version *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyOnnx3 interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneOnnx3(r randyOnnx3) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringOnnx3(r randyOnnx3) string {
	v31 := r.Intn(100)
	tmps := make([]rune, v31)
	for i := 0; i < v31; i++ {
		tmps[i] = randUTF8RuneOnnx3(r)
	}
	return string(tmps)
}
func randUnrecognizedOnnx3(r randyOnnx3, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldOnnx3(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldOnnx3(dAtA []byte, r randyOnnx3, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateOnnx3(dAtA, uint64(key))
		v32 := r.Int63()
		if r.Intn(2) == 0 {
			v32 *= -1
		}
		dAtA = encodeVarintPopulateOnnx3(dAtA, uint64(v32))
	case 1:
		dAtA = encodeVarintPopulateOnnx3(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateOnnx3(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateOnnx3(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateOnnx3(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateOnnx3(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *AttributeProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if m.F != 0 {
		n += 5
	}
	if m.I != 0 {
		n += 1 + sovOnnx3(uint64(m.I))
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if m.T != nil {
		l = m.T.Size()
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if m.G != nil {
		l = m.G.Size()
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if len(m.Floats) > 0 {
		n += 1 + sovOnnx3(uint64(len(m.Floats)*4)) + len(m.Floats)*4
	}
	if len(m.Ints) > 0 {
		l = 0
		for _, e := range m.Ints {
			l += sovOnnx3(uint64(e))
		}
		n += 1 + sovOnnx3(uint64(l)) + l
	}
	if len(m.Strings) > 0 {
		for _, b := range m.Strings {
			l = len(b)
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	if len(m.Tensors) > 0 {
		for _, e := range m.Tensors {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	if len(m.Graphs) > 0 {
		for _, e := range m.Graphs {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	l = len(m.DocString)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if m.Type != 0 {
		n += 2 + sovOnnx3(uint64(m.Type))
	}
	l = len(m.RefAttrName)
	if l > 0 {
		n += 2 + l + sovOnnx3(uint64(l))
	}
	return n
}

func (m *ValueInfoProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovOnnx3(uint64(l))
	}
	l = len(m.DocString)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	return n
}

func (m *NodeProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, s := range m.Input {
			l = len(s)
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	if len(m.Output) > 0 {
		for _, s := range m.Output {
			l = len(s)
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	l = len(m.OpType)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if len(m.Attribute) > 0 {
		for _, e := range m.Attribute {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	l = len(m.DocString)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	return n
}

func (m *ModelProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IrVersion != 0 {
		n += 1 + sovOnnx3(uint64(m.IrVersion))
	}
	l = len(m.ProducerName)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	l = len(m.ProducerVersion)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if m.ModelVersion != 0 {
		n += 1 + sovOnnx3(uint64(m.ModelVersion))
	}
	l = len(m.DocString)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if m.Graph != nil {
		l = m.Graph.Size()
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if len(m.OpsetImport) > 0 {
		for _, e := range m.OpsetImport {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	if len(m.MetadataProps) > 0 {
		for _, e := range m.MetadataProps {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	return n
}

func (m *StringStringEntryProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	return n
}

func (m *TensorAnnotation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TensorName)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if len(m.QuantParameterTensorNames) > 0 {
		for _, e := range m.QuantParameterTensorNames {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	return n
}

func (m *GraphProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Node) > 0 {
		for _, e := range m.Node {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if len(m.Initializer) > 0 {
		for _, e := range m.Initializer {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	l = len(m.DocString)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if len(m.Input) > 0 {
		for _, e := range m.Input {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	if len(m.Output) > 0 {
		for _, e := range m.Output {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	if len(m.ValueInfo) > 0 {
		for _, e := range m.ValueInfo {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	if len(m.QuantizationAnnotation) > 0 {
		for _, e := range m.QuantizationAnnotation {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	return n
}

func (m *TensorProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dims) > 0 {
		l = 0
		for _, e := range m.Dims {
			l += sovOnnx3(uint64(e))
		}
		n += 1 + sovOnnx3(uint64(l)) + l
	}
	if m.DataType != 0 {
		n += 1 + sovOnnx3(uint64(m.DataType))
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if len(m.FloatData) > 0 {
		n += 1 + sovOnnx3(uint64(len(m.FloatData)*4)) + len(m.FloatData)*4
	}
	if len(m.Int32Data) > 0 {
		l = 0
		for _, e := range m.Int32Data {
			l += sovOnnx3(uint64(e))
		}
		n += 1 + sovOnnx3(uint64(l)) + l
	}
	if len(m.StringData) > 0 {
		for _, b := range m.StringData {
			l = len(b)
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	if len(m.Int64Data) > 0 {
		l = 0
		for _, e := range m.Int64Data {
			l += sovOnnx3(uint64(e))
		}
		n += 1 + sovOnnx3(uint64(l)) + l
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	l = len(m.RawData)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if len(m.DoubleData) > 0 {
		n += 1 + sovOnnx3(uint64(len(m.DoubleData)*8)) + len(m.DoubleData)*8
	}
	if len(m.Uint64Data) > 0 {
		l = 0
		for _, e := range m.Uint64Data {
			l += sovOnnx3(uint64(e))
		}
		n += 1 + sovOnnx3(uint64(l)) + l
	}
	l = len(m.DocString)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if len(m.ExternalData) > 0 {
		for _, e := range m.ExternalData {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	if m.DataLocation != 0 {
		n += 1 + sovOnnx3(uint64(m.DataLocation))
	}
	return n
}

func (m *TensorProto_Segment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovOnnx3(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovOnnx3(uint64(m.End))
	}
	return n
}

func (m *TensorShapeProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dim) > 0 {
		for _, e := range m.Dim {
			l = e.Size()
			n += 1 + l + sovOnnx3(uint64(l))
		}
	}
	return n
}

func (m *TensorShapeProto_Dimension) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	l = len(m.Denotation)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	return n
}

func (m *TensorShapeProto_Dimension_DimValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOnnx3(uint64(m.DimValue))
	return n
}
func (m *TensorShapeProto_Dimension_DimParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DimParam)
	n += 1 + l + sovOnnx3(uint64(l))
	return n
}
func (m *TypeProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	l = len(m.Denotation)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	return n
}

func (m *TypeProto_TensorType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TensorType != nil {
		l = m.TensorType.Size()
		n += 1 + l + sovOnnx3(uint64(l))
	}
	return n
}
func (m *TypeProto_Tensor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ElemType != 0 {
		n += 1 + sovOnnx3(uint64(m.ElemType))
	}
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovOnnx3(uint64(l))
	}
	return n
}

func (m *OperatorSetIdProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovOnnx3(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovOnnx3(uint64(m.Version))
	}
	return n
}

func sovOnnx3(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOnnx3(x uint64) (n int) {
	return sovOnnx3(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AttributeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.F = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I", wireType)
			}
			m.I = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.I |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = append(m.S[:0], dAtA[iNdEx:postIndex]...)
			if m.S == nil {
				m.S = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.T == nil {
				m.T = &TensorProto{}
			}
			if err := m.T.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.G == nil {
				m.G = &GraphProto{}
			}
			if err := m.G.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Floats = append(m.Floats, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Floats) == 0 {
					m.Floats = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Floats = append(m.Floats, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Floats", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ints = append(m.Ints, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ints) == 0 {
					m.Ints = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOnnx3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ints = append(m.Ints, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, make([]byte, postIndex-iNdEx))
			copy(m.Strings[len(m.Strings)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tensors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tensors = append(m.Tensors, &TensorProto{})
			if err := m.Tensors[len(m.Tensors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graphs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Graphs = append(m.Graphs, &GraphProto{})
			if err := m.Graphs[len(m.Graphs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AttributeProto_AttributeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefAttrName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefAttrName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &TypeProto{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attribute = append(m.Attribute, &AttributeProto{})
			if err := m.Attribute[len(m.Attribute)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrVersion", wireType)
			}
			m.IrVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IrVersion |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProducerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProducerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			m.ModelVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelVersion |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Graph == nil {
				m.Graph = &GraphProto{}
			}
			if err := m.Graph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpsetImport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpsetImport = append(m.OpsetImport, &OperatorSetIdProto{})
			if err := m.OpsetImport[len(m.OpsetImport)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataProps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataProps = append(m.MetadataProps, &StringStringEntryProto{})
			if err := m.MetadataProps[len(m.MetadataProps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringStringEntryProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringStringEntryProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringStringEntryProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorAnnotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorAnnotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorAnnotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TensorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantParameterTensorNames", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuantParameterTensorNames = append(m.QuantParameterTensorNames, &StringStringEntryProto{})
			if err := m.QuantParameterTensorNames[len(m.QuantParameterTensorNames)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = append(m.Node, &NodeProto{})
			if err := m.Node[len(m.Node)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Initializer = append(m.Initializer, &TensorProto{})
			if err := m.Initializer[len(m.Initializer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input, &ValueInfoProto{})
			if err := m.Input[len(m.Input)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output, &ValueInfoProto{})
			if err := m.Output[len(m.Output)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueInfo = append(m.ValueInfo, &ValueInfoProto{})
			if err := m.ValueInfo[len(m.ValueInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantizationAnnotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuantizationAnnotation = append(m.QuantizationAnnotation, &TensorAnnotation{})
			if err := m.QuantizationAnnotation[len(m.QuantizationAnnotation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dims = append(m.Dims, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dims) == 0 {
					m.Dims = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOnnx3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dims = append(m.Dims, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dims", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &TensorProto_Segment{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.FloatData = append(m.FloatData, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.FloatData) == 0 {
					m.FloatData = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.FloatData = append(m.FloatData, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatData", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Int32Data = append(m.Int32Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Int32Data) == 0 {
					m.Int32Data = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOnnx3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Int32Data = append(m.Int32Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32Data", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringData = append(m.StringData, make([]byte, postIndex-iNdEx))
			copy(m.StringData[len(m.StringData)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Int64Data = append(m.Int64Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Int64Data) == 0 {
					m.Int64Data = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOnnx3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Int64Data = append(m.Int64Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Data", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawData = append(m.RawData[:0], dAtA[iNdEx:postIndex]...)
			if m.RawData == nil {
				m.RawData = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.DoubleData = append(m.DoubleData, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.DoubleData) == 0 {
					m.DoubleData = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.DoubleData = append(m.DoubleData, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleData", wireType)
			}
		case 11:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint64Data = append(m.Uint64Data, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOnnx3
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint64Data) == 0 {
					m.Uint64Data = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOnnx3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint64Data = append(m.Uint64Data, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64Data", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalData = append(m.ExternalData, &StringStringEntryProto{})
			if err := m.ExternalData[len(m.ExternalData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLocation", wireType)
			}
			m.DataLocation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLocation |= (TensorProto_DataLocation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorProto_Segment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorShapeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorShapeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorShapeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dim = append(m.Dim, &TensorShapeProto_Dimension{})
			if err := m.Dim[len(m.Dim)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorShapeProto_Dimension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dimension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dimension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DimValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &TensorShapeProto_Dimension_DimValue{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DimParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &TensorShapeProto_Dimension_DimParam{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TypeProto_Tensor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &TypeProto_TensorType{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeProto_Tensor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tensor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tensor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElemType", wireType)
			}
			m.ElemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElemType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &TensorShapeProto{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorSetIdProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorSetIdProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorSetIdProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOnnx3
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOnnx3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOnnx3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOnnx3(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOnnx3
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOnnx3
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOnnx3
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOnnx3
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOnnx3(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOnnx3 = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOnnx3   = fmt.Errorf("proto: integer overflow")
)
