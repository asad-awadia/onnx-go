package engine

import (
	"bytes"
	"fmt"
	"math"

	"gonum.org/v1/gonum/graph"
	"gonum.org/v1/gonum/graph/iterator"
	"gonum.org/v1/gonum/graph/simple"
)

// START_EXPR_DEF OMIT

// ExprGraph is a data structure for a directed acyclic graph (of expressions). This structure is the main entry point
// for Gorgonia.
type ExprGraph struct {
	w    *simple.WeightedDirectedGraph
	name string

	byHash map[uint32]*Node
	evac   map[uint32]Nodes
	to     map[*Node]Nodes

	leaves    Nodes
	constants Nodes
	roots     Nodes
	counter   uint
}

// END_EXPR_DEF OMIT

// Graphconopt is a construction function of a graph
type Graphconopt func(g *ExprGraph)

// WithGraphName is a ExprGraph construction option that provides a name.
func WithGraphName(name string) Graphconopt {
	f := func(g *ExprGraph) {
		g.name = name
	}
	return f
}

// NewGraph creates a new graph. Duh
func NewGraph(opts ...Graphconopt) *ExprGraph {
	g := &ExprGraph{
		w:      simple.NewWeightedDirectedGraph(math.MaxFloat64, -1),
		byHash: make(map[uint32]*Node),
		evac:   make(map[uint32]Nodes),
		to:     make(map[*Node]Nodes),

		leaves:    make(Nodes, 0, 64),
		constants: make(Nodes, 0, 8),
	}

	for _, opt := range opts {
		opt(g)
	}

	return g
}

// Attach the node to the graph and returns the self node.
//    a := g.Attach(g.NewNode())
// is equivalent to
// a := NewNode()
// g.AddNode(a)
func (g *ExprGraph) Attach(n *Node) *Node {
	g.AddNode(n)
	return n
}

// Has returns true if the id is present in the graph
func (g *ExprGraph) Has(id int64) bool {
	it := g.Nodes()
	for it.Next() {
		if it.Node().ID() == id {
			return true
		}
	}
	return false
}

// RemoveNode removes the node with the given ID from the graph, as well as any edges attached to it. If the node is not in the graph it is a no-op.
func (g *ExprGraph) RemoveNode(id int64) {
	g.w.RemoveNode(id)
}

// Roots returns a list of nodes that are not children of any other nodes
func (g *ExprGraph) Roots() (retVal Nodes) {
	// handle subgraph
	if g.roots != nil {
		return g.roots
	}

	for n, tos := range g.to {
		if len(tos) == 0 {
			retVal = append(retVal, n)
		}
		// if the root is a statement (typically a read), and it only has one child
		if len(n.children) == 1 && n.isStmt {
			child := n.children[0]
			if len(g.to[child]) == 1 {
				retVal = append(retVal, child)
			}
		}
	}
	g.roots = retVal
	return retVal
}

// Inputs returns a list of nodes which are inputs (that is to say, the user is required to set a value in it)
func (g *ExprGraph) Inputs() *iterator.OrderedNodes {
	retVal := make([]graph.Node, 0)
	it := g.Nodes()
	for it.Next() {
		n := it.Node().(*Node)
		if n.isInput() {
			retVal = append(retVal, n)
		}

	}
	return iterator.NewOrderedNodes(retVal)
}

// UnbindAll unbinds all the values from the nodes
func (g *ExprGraph) UnbindAll() {
	it := g.Nodes()
	for it.Next() {
		it.Node().(*Node).unbind()
	}
}

// UnbindAllNonInputs unbinds all the values from nodes that aren't input nodes
func (g *ExprGraph) UnbindAllNonInputs() {
	it := g.Nodes()
	for it.Next() {
		n := it.Node().(*Node)
		if n.isInput() || n.isConstant() {
			continue
		}
		n.unbind()
	}
}

// ByName returns nodes that have the name provided.
// Bear in mind that the name that is compared to is the internal name,
// not the result of calling node.Name(). The reason for doing this is
// for ease of finding only names that are user-supplied, instead of autogenerated names
func (g *ExprGraph) ByName(name string) (retVal Nodes) {
	it := g.w.Nodes()
	for it.Next() {
		n := it.Node().(*Node)
		if n.name == name {
			retVal = append(retVal, n)
		}
	}
	return
}

// Constant returns a constant that may be found in the graph. If no constant were found, a new one is created instead
/*
func (g *ExprGraph) Constant(v value.Value) *Node {
	for _, n := range g.constants {
		if value.ValueEq(n.Value(), v) {
			return n
		}
	}

	n := NewConstant(v)
	return g.AddNode(n)
}*/

func (g *ExprGraph) String() string {
	var buf bytes.Buffer
	buf.WriteString("Graph: [\n")
	it := g.Nodes()
	for it.Next() {
		n := it.Node().(*Node)
		fmt.Fprintf(&buf, "\t%d: %s\n", n.Hashcode(), n)
	}
	buf.WriteString("]")
	return buf.String()
}

// other private methods

func (g *ExprGraph) removeAllEdgesFrom(n *Node) {
	for k, ns := range g.to {
		g.to[k] = ns.remove(n)
	}
}

// subgraph is basically a subset of nodes. This is useful for compiling sub sections of the graph
func (g *ExprGraph) subgraph(ns Nodes, findMissing bool, opts ...Nodes) *ExprGraph {
	// ns = ns.Set()

	var roots Nodes
	// add missing stuff first
	if findMissing {
		for _, n := range ns {
			for _, parent := range g.to[n] {
				if parent.isStmt {
					roots = append(roots, parent)
					ns = append(ns, parent)
				}
			}
		}
	}

	// uniquify the froms and at the same time build a new roots
	allset := ns.mapSet()
	if len(opts) == 0 {
		for _, n := range ns {
			if len(g.to[n]) == 0 {
				if n.isStmt {
					roots = append(roots, n.children[0])
				} else {
					roots = append(roots, n)
				}
				continue
			}

			var hasParent bool
			for _, parent := range g.to[n] {
				if allset.Contains(parent) {
					hasParent = true
					break
				}
			}
			if !hasParent {
				roots = append(roots, n)
			}
		}
	} else {
		rs := opts[0]
		roots = make(Nodes, len(rs))
		for i, n := range rs {
			if n.isStmt {
				roots[i] = n.children[0]
				continue
			}
			roots[i] = n

		}
	}
	var leaves Nodes
	for _, n := range ns {
		if len(n.children) == 0 {
			leaves = append(leaves, n)
		}
	}

	// uniquify all the things
	roots = roots.Set()
	leaves = leaves.Set()
	ns = ns.Set()

	retVal := &ExprGraph{
		byHash: g.byHash,
		evac:   g.evac,
		to:     g.to,

		leaves:    leaves,
		constants: g.constants,
		roots:     roots,
	}

	return retVal
}

// Subgraph subsets a graph. This function has overloaded meanings - If only one node is passed in, it assumes that the one node is the root,
// otherwise, it treats ns as the subset of nodes to be included in the subgraph
func (g *ExprGraph) Subgraph(ns ...*Node) *ExprGraph {
	if len(ns) == 1 {
		g.SubgraphRoots(ns[0])
	}
	return g.subgraph(ns, true)
}

// SubgraphRoots creates a subgraph, assuming the provided nodes are roots to the new subgraph.
func (g *ExprGraph) SubgraphRoots(ns ...*Node) *ExprGraph {
	sub := g.walkFromRoots(ns...)
	return g.subgraph(sub, true, ns)
}

// ExactSubgraphRoots creates a subgraph from the roots provided.
// The difference between SubgraphRoots and ExactSubgraphRoots is that ExactSubGraphRoots
// will not attempt to discover if any nodes are missing.
//
// Given a function like the following:
//		z = x + y
//		set(x, -x.Grad) // setting the value of x to the negative of the gradient
//
// When SubgraphRoots is used on z, the `-x.Grad` will be included.
// When using ExactSubgraphRoots, only `x` and `y` are included in the subgraph
func (g *ExprGraph) ExactSubgraphRoots(ns ...*Node) *ExprGraph {
	sub := g.walkFromRoots(ns...)
	return g.subgraph(sub, false, ns)
}

func (g *ExprGraph) walkFromRoots(ns ...*Node) Nodes {
	sub := make(Nodes, len(ns))
	copy(sub, ns)

	walked := NewNodeSet()
	for _, n := range ns {
		ch := make(chan *Node)
		go func(ch chan *Node) {
			defer close(ch)
			walkGraph(n, ch, walked)
		}(ch)

		for node := range ch {
			sub = append(sub, node)
		}
	}
	return sub
}

type edge struct {
	from, to graph.Node
	weight   float64
}

func (e edge) From() graph.Node { return e.from }
func (e edge) To() graph.Node   { return e.to }
func (e edge) Weight() float64  { return e.weight }
