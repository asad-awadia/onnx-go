package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"os/user"
	"path"
	"strings"
	"text/template"
)

const genmsg = "// Code generated by genapi, which is a API generation tool for Gorgonia. DO NOT EDIT."

const (
	apigenOut = "api_gen.go"
	unaryOps  = "operatorPointwise_unary_const.go"
	binaryOps = "operatorPointwise_binary_const.go"
)

var (
	gopath, engineloc, onnxloc, gorgonialoc string
)

var funcmap = template.FuncMap{
	"lower": strings.ToLower,
}

var (
	onnxUnaryTemplate      *template.Template
	onnxBinaryTemplate     *template.Template
	gorgoniaUnaryTemplate  *template.Template
	gorgoniaBinaryTemplate *template.Template
	engineUnaryTemplate    *template.Template
	engineBinaryTemplate   *template.Template
)

func init() {
	gopath = os.Getenv("GOPATH")
	// now that go can have a default gopath, this checks that path
	if gopath == "" {
		usr, err := user.Current()
		if err != nil {
			log.Fatal(err)
		}
		gopath = path.Join(usr.HomeDir, "go")
		stat, err := os.Stat(gopath)
		if err != nil {
			log.Fatal(err)
		}
		if !stat.IsDir() {
			log.Fatal("You need to define a $GOPATH")
		}
	}
	engineloc = path.Join(gopath, "src/gorgonia.org/gorgonia/internal/engine")
	gorgonialoc = path.Join(gopath, "src/gorgonia.org/gorgonia")
	onnxloc = path.Join(gopath, "src/gorgonia.org/gorgonia/onnx")
	engineUnaryTemplate = template.Must(template.New("Unary").Funcs(funcmap).Parse(engineUnaryTemplateRaw))
	engineBinaryTemplate = template.Must(template.New("Binary").Funcs(funcmap).Parse(engineBinaryTemplateRaw))
	onnxUnaryTemplate = template.Must(template.New("Unary").Funcs(funcmap).Parse(onnxUnaryTemplateRaw))
	onnxBinaryTemplate = template.Must(template.New("Binary").Funcs(funcmap).Parse(onnxBinaryTemplateRaw))
	gorgoniaUnaryTemplate = template.Must(template.New("Unary").Funcs(funcmap).Parse(gorgoniaUnaryTemplateRaw))
	gorgoniaBinaryTemplate = template.Must(template.New("Binary").Funcs(funcmap).Parse(gorgoniaBinaryTemplateRaw))
}

func generateUnary(tmpl *template.Template, outFile io.Writer) {
	// parse operator_unary_const.go
	filename := path.Join(engineloc, unaryOps)
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filename, nil, parser.AllErrors)
	if err != nil {
		log.Fatal(err)
	}

	unaryNames := constTypes(file.Decls, "ʘUnaryOperatorType", "maxʘUnaryOperator")
	for _, v := range unaryNames {
		apiName := strings.Title(strings.TrimSuffix(v, "OpType"))
		// legacy issue
		if apiName == "Ln" {
			apiName = "Log"
		}
		data := struct{ FnName, OpType string }{apiName, v}
		tmpl.Execute(outFile, data)
	}

}
func generateBinary(tmpl *template.Template, outFile io.Writer) {
	// parse operator_binary_const.go
	filename := path.Join(engineloc, binaryOps)
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filename, nil, parser.AllErrors)
	if err != nil {
		log.Fatal(err)
	}

	binaryNames := constTypes(file.Decls, "ʘBinaryOperatorType", "maxʘBinaryOpType")
	log.Printf("%v", binaryNames)
	for _, v := range binaryNames {
		apiName := strings.Title(strings.TrimSuffix(v, "OpType"))
		// legacy issue
		switch apiName {
		case "Mul":
			apiName = "HadamardProd"
		case "Div":
			apiName = "HadamardDiv"
		}
		data := struct {
			FnName, OpType string
			AsSame         bool
		}{apiName, v, false}
		switch apiName {
		case "Lt", "Gt", "Lte", "Gte", "Eq", "Ne":
			data.AsSame = true
		}
		tmpl.Execute(outFile, data)
	}
}

func constTypes(decls []ast.Decl, accept, max string) (names []string) {
	for i, decl := range decls {
		log.Printf("DECL %d: %T", i, decl)
		switch d := decl.(type) {
		case *ast.GenDecl:
			if d.Tok.IsKeyword() && d.Tok.String() == "const" {
				log.Printf("\t%v", d.Tok.String())

				// get the type
				if len(d.Specs) == 0 {
					continue
				}

				var typename string
				typ := d.Specs[0].(*ast.ValueSpec).Type
				if typ == nil {
					continue
				}
				if id, ok := typ.(*ast.Ident); ok {
					typename = id.Name
				}
				if typename != accept {
					continue
				}

				for _, spec := range d.Specs {
					name := spec.(*ast.ValueSpec).Names[0].Name
					if name == max {
						continue
					}
					names = append(names, name)
				}
			}
		default:
		}
	}
	return
}

func main() {
	var outFileName string
	var err error
	var outFile *os.File

	outFileName = path.Join(engineloc, apigenOut)
	outFile, err = os.OpenFile(outFileName, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Fprintf(outFile, engineHeader, genmsg)

	generateUnary(engineUnaryTemplate, outFile)
	generateBinary(engineBinaryTemplate, outFile)
	outFile.Close()

	outFileName = path.Join(onnxloc, apigenOut)
	outFile, err = os.OpenFile(outFileName, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Fprintf(outFile, onnxHeader, genmsg)

	generateUnary(onnxUnaryTemplate, outFile)
	generateBinary(onnxBinaryTemplate, outFile)
	outFile.Close()

	outFileName = path.Join(gorgonialoc, apigenOut)
	outFile, err = os.OpenFile(outFileName, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Fprintf(outFile, gorgoniaHeader, genmsg)

	generateUnary(gorgoniaUnaryTemplate, outFile)
	generateBinary(gorgoniaBinaryTemplate, outFile)
	outFile.Close()
}
